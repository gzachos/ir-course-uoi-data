
<!DOCTYPE html>
<html class="client-nojs" lang="en" dir="ltr">
<head>
<meta charset="UTF-8"/>
<title>Primitive recursive function - Wikipedia</title>
<script>document.documentElement.className="client-js";RLCONF={"wgBreakFrames":!1,"wgSeparatorTransformTable":["",""],"wgDigitTransformTable":["",""],"wgDefaultDateFormat":"dmy","wgMonthNames":["","January","February","March","April","May","June","July","August","September","October","November","December"],"wgRequestId":"XpcvmQpAMNMAA88dXoUAAACK","wgCSPNonce":!1,"wgCanonicalNamespace":"","wgCanonicalSpecialPageName":!1,"wgNamespaceNumber":0,"wgPageName":"Primitive_recursive_function","wgTitle":"Primitive recursive function","wgCurRevisionId":946623663,"wgRevisionId":946623663,"wgArticleId":24829,"wgIsArticle":!0,"wgIsRedirect":!1,"wgAction":"view","wgUserName":null,"wgUserGroups":["*"],"wgCategories":["Computability theory","Theory of computation","Functions and mappings","Recursion"],"wgPageContentLanguage":"en","wgPageContentModel":"wikitext","wgRelevantPageName":"Primitive_recursive_function","wgRelevantArticleId":24829,"wgIsProbablyEditable":!0,
"wgRelevantPageIsProbablyEditable":!0,"wgRestrictionEdit":[],"wgRestrictionMove":[],"wgMediaViewerOnClick":!0,"wgMediaViewerEnabledByDefault":!0,"wgPopupsReferencePreviews":!1,"wgPopupsConflictsWithNavPopupGadget":!1,"wgVisualEditor":{"pageLanguageCode":"en","pageLanguageDir":"ltr","pageVariantFallbacks":"en"},"wgMFDisplayWikibaseDescriptions":{"search":!0,"nearby":!0,"watchlist":!0,"tagline":!1},"wgWMESchemaEditAttemptStepOversample":!1,"wgULSCurrentAutonym":"English","wgNoticeProject":"wikipedia","wgWikibaseItemId":"Q1570472","wgCentralAuthMobileDomain":!1,"wgEditSubmitButtonLabelPublish":!0};RLSTATE={"ext.globalCssJs.user.styles":"ready","site.styles":"ready","noscript":"ready","user.styles":"ready","ext.globalCssJs.user":"ready","user":"ready","user.options":"loading","ext.cite.styles":"ready","ext.math.styles":"ready","jquery.makeCollapsible.styles":"ready","mediawiki.toc.styles":"ready","skins.vector.styles.legacy":"ready","wikibase.client.init":
"ready","ext.visualEditor.desktopArticleTarget.noscript":"ready","ext.uls.interlanguage":"ready","ext.wikimediaBadges":"ready"};RLPAGEMODULES=["ext.cite.ux-enhancements","ext.math.scripts","site","mediawiki.page.startup","skins.vector.js","mediawiki.page.ready","jquery.makeCollapsible","mediawiki.toc","ext.gadget.ReferenceTooltips","ext.gadget.charinsert","ext.gadget.refToolbar","ext.gadget.extra-toolbar-buttons","ext.gadget.switcher","ext.centralauth.centralautologin","ext.popups","ext.visualEditor.desktopArticleTarget.init","ext.visualEditor.targetLoader","ext.eventLogging","ext.wikimediaEvents","ext.navigationTiming","ext.uls.compactlinks","ext.uls.interface","ext.cx.eventlogging.campaigns","ext.quicksurveys.init","ext.centralNotice.geoIP","ext.centralNotice.startUp"];</script>
<script>(RLQ=window.RLQ||[]).push(function(){mw.loader.implement("user.options@1hzgi",function($,jQuery,require,module){/*@nomin*/mw.user.tokens.set({"patrolToken":"+\\","watchToken":"+\\","csrfToken":"+\\"});
});});</script>
<link rel="stylesheet" href="/w/load.php?lang=en&amp;modules=ext.cite.styles%7Cext.math.styles%7Cext.uls.interlanguage%7Cext.visualEditor.desktopArticleTarget.noscript%7Cext.wikimediaBadges%7Cjquery.makeCollapsible.styles%7Cmediawiki.toc.styles%7Cskins.vector.styles.legacy%7Cwikibase.client.init&amp;only=styles&amp;skin=vector"/>
<script async="" src="/w/load.php?lang=en&amp;modules=startup&amp;only=scripts&amp;raw=1&amp;skin=vector"></script>
<meta name="ResourceLoaderDynamicStyles" content=""/>
<link rel="stylesheet" href="/w/load.php?lang=en&amp;modules=site.styles&amp;only=styles&amp;skin=vector"/>
<meta name="generator" content="MediaWiki 1.35.0-wmf.27"/>
<meta name="referrer" content="origin"/>
<meta name="referrer" content="origin-when-crossorigin"/>
<meta name="referrer" content="origin-when-cross-origin"/>
<link rel="alternate" type="application/x-wiki" title="Edit this page" href="/w/index.php?title=Primitive_recursive_function&amp;action=edit"/>
<link rel="edit" title="Edit this page" href="/w/index.php?title=Primitive_recursive_function&amp;action=edit"/>
<link rel="apple-touch-icon" href="/static/apple-touch/wikipedia.png"/>
<link rel="shortcut icon" href="/static/favicon/wikipedia.ico"/>
<link rel="search" type="application/opensearchdescription+xml" href="/w/opensearch_desc.php" title="Wikipedia (en)"/>
<link rel="EditURI" type="application/rsd+xml" href="//en.wikipedia.org/w/api.php?action=rsd"/>
<link rel="license" href="//creativecommons.org/licenses/by-sa/3.0/"/>
<link rel="alternate" type="application/atom+xml" title="Wikipedia Atom feed" href="/w/index.php?title=Special:RecentChanges&amp;feed=atom"/>
<link rel="canonical" href="https://en.wikipedia.org/wiki/Primitive_recursive_function"/>
<link rel="dns-prefetch" href="//login.wikimedia.org"/>
<link rel="dns-prefetch" href="//meta.wikimedia.org" />
<!--[if lt IE 9]><script src="/w/resources/lib/html5shiv/html5shiv.js"></script><![endif]-->
</head>
<body class="mediawiki ltr sitedir-ltr mw-hide-empty-elt ns-0 ns-subject mw-editable page-Primitive_recursive_function rootpage-Primitive_recursive_function skin-vector action-view">
<div id="mw-page-base" class="noprint"></div>
<div id="mw-head-base" class="noprint"></div>
<div id="content" class="mw-body" role="main">
	<a id="top"></a>
	<div id="siteNotice" class="mw-body-content"><!-- CentralNotice --></div>
	<div class="mw-indicators mw-body-content">
</div>

	<h1 id="firstHeading" class="firstHeading" lang="en">Primitive recursive function</h1>
	
	<div id="bodyContent" class="mw-body-content">
		<div id="siteSub" class="noprint">From Wikipedia, the free encyclopedia</div>
		<div id="contentSub"></div>
		
		
		<div id="jump-to-nav"></div>
		<a class="mw-jump-link" href="#mw-head">Jump to navigation</a>
		<a class="mw-jump-link" href="#p-search">Jump to search</a>
		<div id="mw-content-text" lang="en" dir="ltr" class="mw-content-ltr"><div class="mw-parser-output"><p>In <a href="/wiki/Computability_theory" title="Computability theory">computability theory</a>, a <b>primitive recursive function</b> is roughly speaking a function that can be computed by a <a href="/wiki/Computer_program" title="Computer program">computer program</a> whose <a href="/wiki/Loop_(programming)" class="mw-redirect" title="Loop (programming)">loops</a> are all "for" loops (that is, an upper bound of the number of iterations of every loop can be determined before entering the loop). Primitive recursive functions form a strict <a href="/wiki/Subset" title="Subset">subset</a> of those <a href="/wiki/General_recursive_function" title="General recursive function">general recursive functions</a> that are also <a href="/wiki/Total_function" class="mw-redirect" title="Total function">total functions</a>. 
</p><p>The importance of primitive recursive functions lies on the fact that most computable functions that are studied in <a href="/wiki/Number_theory" title="Number theory">number theory</a> (and more generally in mathematics) are primitive recursive. For example, <a href="/wiki/Addition" title="Addition">addition</a> and <a href="/wiki/Division_(mathematics)" title="Division (mathematics)">division</a>, the <a href="/wiki/Factorial" title="Factorial">factorial</a> and <a href="/wiki/Exponential_function" title="Exponential function">exponential</a> function, and the function which returns the <i>n</i>th prime are all primitive recursive.<sup id="cite_ref-1" class="reference"><a href="#cite_note-1">&#91;1&#93;</a></sup> In fact, for showing that a computable function is primitive recursive, it suffices to show that its <a href="/wiki/Computational_complexity" title="Computational complexity">computational complexity</a> is bounded above by a primitive recursive function of the input size. It follows that it is difficult to devise a <a href="/wiki/Computable_function" title="Computable function">computable function</a> that is <i>not</i> primitive recursive, although some are known (see the section on <a href="/wiki/Primitive_recursive_function#Limitations" title="Primitive recursive function">Limitations</a> below).
</p><p>The set of primitive recursive functions is known as <a href="/wiki/PR_(complexity)" title="PR (complexity)">PR</a> in <a href="/wiki/Computational_complexity_theory" title="Computational complexity theory">computational complexity theory</a>.
</p>
<div id="toc" class="toc" role="navigation" aria-labelledby="mw-toc-heading"><input type="checkbox" role="button" id="toctogglecheckbox" class="toctogglecheckbox" style="display:none" /><div class="toctitle" lang="en" dir="ltr"><h2 id="mw-toc-heading">Contents</h2><span class="toctogglespan"><label class="toctogglelabel" for="toctogglecheckbox"></label></span></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#Definition"><span class="tocnumber">1</span> <span class="toctext">Definition</span></a>
<ul>
<li class="toclevel-2 tocsection-2"><a href="#Role_of_the_projection_functions"><span class="tocnumber">1.1</span> <span class="toctext">Role of the projection functions</span></a></li>
<li class="toclevel-2 tocsection-3"><a href="#Converting_predicates_to_numeric_functions"><span class="tocnumber">1.2</span> <span class="toctext">Converting predicates to numeric functions</span></a></li>
<li class="toclevel-2 tocsection-4"><a href="#Computer_language_definition"><span class="tocnumber">1.3</span> <span class="toctext">Computer language definition</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-5"><a href="#Examples"><span class="tocnumber">2</span> <span class="toctext">Examples</span></a>
<ul>
<li class="toclevel-2 tocsection-6"><a href="#Addition"><span class="tocnumber">2.1</span> <span class="toctext">Addition</span></a></li>
<li class="toclevel-2 tocsection-7"><a href="#Subtraction"><span class="tocnumber">2.2</span> <span class="toctext">Subtraction</span></a></li>
<li class="toclevel-2 tocsection-8"><a href="#Other_operations_on_natural_numbers"><span class="tocnumber">2.3</span> <span class="toctext">Other operations on natural numbers</span></a></li>
<li class="toclevel-2 tocsection-9"><a href="#Operations_on_integers_and_rational_numbers"><span class="tocnumber">2.4</span> <span class="toctext">Operations on integers and rational numbers</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-10"><a href="#Use_in_first-order_Peano_arithmetic"><span class="tocnumber">3</span> <span class="toctext">Use in first-order Peano arithmetic</span></a></li>
<li class="toclevel-1 tocsection-11"><a href="#Relationship_to_recursive_functions"><span class="tocnumber">4</span> <span class="toctext">Relationship to recursive functions</span></a></li>
<li class="toclevel-1 tocsection-12"><a href="#Limitations"><span class="tocnumber">5</span> <span class="toctext">Limitations</span></a></li>
<li class="toclevel-1 tocsection-13"><a href="#Some_common_primitive_recursive_functions"><span class="tocnumber">6</span> <span class="toctext">Some common primitive recursive functions</span></a></li>
<li class="toclevel-1 tocsection-14"><a href="#Additional_primitive_recursive_forms"><span class="tocnumber">7</span> <span class="toctext">Additional primitive recursive forms</span></a></li>
<li class="toclevel-1 tocsection-15"><a href="#Finitism_and_consistency_results"><span class="tocnumber">8</span> <span class="toctext">Finitism and consistency results</span></a></li>
<li class="toclevel-1 tocsection-16"><a href="#History"><span class="tocnumber">9</span> <span class="toctext">History</span></a></li>
<li class="toclevel-1 tocsection-17"><a href="#See_also"><span class="tocnumber">10</span> <span class="toctext">See also</span></a></li>
<li class="toclevel-1 tocsection-18"><a href="#Notes"><span class="tocnumber">11</span> <span class="toctext">Notes</span></a></li>
<li class="toclevel-1 tocsection-19"><a href="#References"><span class="tocnumber">12</span> <span class="toctext">References</span></a></li>
</ul>
</div>

<h2><span class="mw-headline" id="Definition">Definition</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Primitive_recursive_function&amp;action=edit&amp;section=1" title="Edit section: Definition">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>The primitive recursive functions are among the number-theoretic functions, which are functions from the <a href="/wiki/Natural_number" title="Natural number">natural numbers</a> (nonnegative integers) {0, 1, 2, ...} to the natural numbers. These functions take <i>n</i> arguments for some natural number <i>n</i> and are called <i>n</i>-<a href="/wiki/Arity" title="Arity">ary</a>.
</p><p>The basic primitive recursive functions are given by these <a href="/wiki/Axiom" title="Axiom">axioms</a>:
</p>
<div><ol start="1"><li><b>Constant function</b>: The 0-ary <a href="/wiki/Constant_term" title="Constant term">constant function</a> 0 is primitive recursive.</li><li><b>Successor function</b>: The 1-ary successor function <i>S</i>, which returns the successor of its argument (see <a href="/wiki/Peano_postulates" class="mw-redirect" title="Peano postulates">Peano postulates</a>), is primitive recursive. That is, <i>S</i>(<i>k</i>) = <i>k</i> + 1.</li><li><b>Projection function</b>: For every <i>n</i>≥1 and each <i>i</i> with 1≤<i>i</i>≤<i>n</i>, the <i>n</i>-ary projection function <i>P</i><sub><i>i</i></sub><sup><i>n</i></sup>, which returns its <i>i</i>-th argument, is primitive recursive.</li></ol></div>
<p>More complex primitive recursive functions can be obtained by applying the <a href="/wiki/Operation_(mathematics)" title="Operation (mathematics)">operations</a> given by these axioms:
</p>
<div><ol start="4"><li><b>Composition</b>: Given a <i>k</i>-ary primitive recursive function <i>f</i>, and <i>k</i> many <i>m</i>-ary primitive recursive functions <i>g</i><sub>1</sub>,...,<i>g</i><sub><i>k</i></sub>, the <a href="/wiki/Function_composition" title="Function composition">composition</a> of <i>f</i> with <i>g</i><sub>1</sub>,...,<i>g</i><sub><i>k</i></sub>, i.e. the <i>m</i>-ary function <span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math xmlns="http://www.w3.org/1998/Math/MathML"  alttext="{\displaystyle h(x_{1},\ldots ,x_{m})=f(g_{1}(x_{1},\ldots ,x_{m}),\ldots ,g_{k}(x_{1},\ldots ,x_{m}))\,}">
  <semantics>
    <mrow class="MJX-TeXAtom-ORD">
      <mstyle displaystyle="true" scriptlevel="0">
        <mi>h</mi>
        <mo stretchy="false">(</mo>
        <msub>
          <mi>x</mi>
          <mrow class="MJX-TeXAtom-ORD">
            <mn>1</mn>
          </mrow>
        </msub>
        <mo>,</mo>
        <mo>&#x2026;<!-- … --></mo>
        <mo>,</mo>
        <msub>
          <mi>x</mi>
          <mrow class="MJX-TeXAtom-ORD">
            <mi>m</mi>
          </mrow>
        </msub>
        <mo stretchy="false">)</mo>
        <mo>=</mo>
        <mi>f</mi>
        <mo stretchy="false">(</mo>
        <msub>
          <mi>g</mi>
          <mrow class="MJX-TeXAtom-ORD">
            <mn>1</mn>
          </mrow>
        </msub>
        <mo stretchy="false">(</mo>
        <msub>
          <mi>x</mi>
          <mrow class="MJX-TeXAtom-ORD">
            <mn>1</mn>
          </mrow>
        </msub>
        <mo>,</mo>
        <mo>&#x2026;<!-- … --></mo>
        <mo>,</mo>
        <msub>
          <mi>x</mi>
          <mrow class="MJX-TeXAtom-ORD">
            <mi>m</mi>
          </mrow>
        </msub>
        <mo stretchy="false">)</mo>
        <mo>,</mo>
        <mo>&#x2026;<!-- … --></mo>
        <mo>,</mo>
        <msub>
          <mi>g</mi>
          <mrow class="MJX-TeXAtom-ORD">
            <mi>k</mi>
          </mrow>
        </msub>
        <mo stretchy="false">(</mo>
        <msub>
          <mi>x</mi>
          <mrow class="MJX-TeXAtom-ORD">
            <mn>1</mn>
          </mrow>
        </msub>
        <mo>,</mo>
        <mo>&#x2026;<!-- … --></mo>
        <mo>,</mo>
        <msub>
          <mi>x</mi>
          <mrow class="MJX-TeXAtom-ORD">
            <mi>m</mi>
          </mrow>
        </msub>
        <mo stretchy="false">)</mo>
        <mo stretchy="false">)</mo>
        <mspace width="thinmathspace" />
      </mstyle>
    </mrow>
    <annotation encoding="application/x-tex">{\displaystyle h(x_{1},\ldots ,x_{m})=f(g_{1}(x_{1},\ldots ,x_{m}),\ldots ,g_{k}(x_{1},\ldots ,x_{m}))\,}</annotation>
  </semantics>
</math></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/54bf3446819f126ac4104068d14aeb46f69e9894" class="mwe-math-fallback-image-inline" aria-hidden="true" style="vertical-align: -0.838ex; width:54.58ex; height:2.843ex;" alt="h(x_1,\ldots,x_m) = f(g_1(x_1,\ldots,x_m),\ldots,g_k(x_1,\ldots,x_m)) \,"/></span> is primitive recursive.</li></ol></div>
<p>Example. We take <i>f</i>(<i>x</i>) as the <i>S</i>(<i>x</i>) defined above. This f is a 1-ary primitive recursive function. And so is <i>g</i>(<i>x</i>) = <i>S</i>(<i>x</i>). So <i>h</i>(<i>x</i>) defined as <i>f</i>(<i>g</i>(<i>x</i>)) = <i>S</i>(<i>S</i>(<i>x</i>)) is a primitive recursive 1-ary function too. Informally speaking, <i>h</i>(<i>x</i>) is the function that turns <i>x</i> into <i>x</i>+2.
</p>
<div><ol start="5"><li><b>Primitive recursion</b>: Given <i>f</i>, a <i>k</i>-ary primitive recursive function, and <i>g</i>, a (<i>k</i>+2)-ary primitive recursive function, the (<i>k</i>+1)-ary function <i>h</i> is defined as the primitive recursion of <i>f</i> and <i>g</i>, i.e. the function <i>h</i> is primitive recursive when
<dl><dd><span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math xmlns="http://www.w3.org/1998/Math/MathML"  alttext="{\displaystyle h(0,x_{1},\ldots ,x_{k})=f(x_{1},\ldots ,x_{k})\,}">
  <semantics>
    <mrow class="MJX-TeXAtom-ORD">
      <mstyle displaystyle="true" scriptlevel="0">
        <mi>h</mi>
        <mo stretchy="false">(</mo>
        <mn>0</mn>
        <mo>,</mo>
        <msub>
          <mi>x</mi>
          <mrow class="MJX-TeXAtom-ORD">
            <mn>1</mn>
          </mrow>
        </msub>
        <mo>,</mo>
        <mo>&#x2026;<!-- … --></mo>
        <mo>,</mo>
        <msub>
          <mi>x</mi>
          <mrow class="MJX-TeXAtom-ORD">
            <mi>k</mi>
          </mrow>
        </msub>
        <mo stretchy="false">)</mo>
        <mo>=</mo>
        <mi>f</mi>
        <mo stretchy="false">(</mo>
        <msub>
          <mi>x</mi>
          <mrow class="MJX-TeXAtom-ORD">
            <mn>1</mn>
          </mrow>
        </msub>
        <mo>,</mo>
        <mo>&#x2026;<!-- … --></mo>
        <mo>,</mo>
        <msub>
          <mi>x</mi>
          <mrow class="MJX-TeXAtom-ORD">
            <mi>k</mi>
          </mrow>
        </msub>
        <mo stretchy="false">)</mo>
        <mspace width="thinmathspace" />
      </mstyle>
    </mrow>
    <annotation encoding="application/x-tex">{\displaystyle h(0,x_{1},\ldots ,x_{k})=f(x_{1},\ldots ,x_{k})\,}</annotation>
  </semantics>
</math></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/9a923da173c9a3ad7ffaff97be3c3560192a5177" class="mwe-math-fallback-image-inline" aria-hidden="true" style="vertical-align: -0.838ex; width:31.879ex; height:2.843ex;" alt="h (0, x_1, \ldots, x_k) = f (x_1, \ldots, x_k) \,"/></span> and</dd>
<dd><span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math xmlns="http://www.w3.org/1998/Math/MathML"  alttext="{\displaystyle h(S(y),x_{1},\ldots ,x_{k})=g(y,h(y,x_{1},\ldots ,x_{k}),x_{1},\ldots ,x_{k})\,.}">
  <semantics>
    <mrow class="MJX-TeXAtom-ORD">
      <mstyle displaystyle="true" scriptlevel="0">
        <mi>h</mi>
        <mo stretchy="false">(</mo>
        <mi>S</mi>
        <mo stretchy="false">(</mo>
        <mi>y</mi>
        <mo stretchy="false">)</mo>
        <mo>,</mo>
        <msub>
          <mi>x</mi>
          <mrow class="MJX-TeXAtom-ORD">
            <mn>1</mn>
          </mrow>
        </msub>
        <mo>,</mo>
        <mo>&#x2026;<!-- … --></mo>
        <mo>,</mo>
        <msub>
          <mi>x</mi>
          <mrow class="MJX-TeXAtom-ORD">
            <mi>k</mi>
          </mrow>
        </msub>
        <mo stretchy="false">)</mo>
        <mo>=</mo>
        <mi>g</mi>
        <mo stretchy="false">(</mo>
        <mi>y</mi>
        <mo>,</mo>
        <mi>h</mi>
        <mo stretchy="false">(</mo>
        <mi>y</mi>
        <mo>,</mo>
        <msub>
          <mi>x</mi>
          <mrow class="MJX-TeXAtom-ORD">
            <mn>1</mn>
          </mrow>
        </msub>
        <mo>,</mo>
        <mo>&#x2026;<!-- … --></mo>
        <mo>,</mo>
        <msub>
          <mi>x</mi>
          <mrow class="MJX-TeXAtom-ORD">
            <mi>k</mi>
          </mrow>
        </msub>
        <mo stretchy="false">)</mo>
        <mo>,</mo>
        <msub>
          <mi>x</mi>
          <mrow class="MJX-TeXAtom-ORD">
            <mn>1</mn>
          </mrow>
        </msub>
        <mo>,</mo>
        <mo>&#x2026;<!-- … --></mo>
        <mo>,</mo>
        <msub>
          <mi>x</mi>
          <mrow class="MJX-TeXAtom-ORD">
            <mi>k</mi>
          </mrow>
        </msub>
        <mo stretchy="false">)</mo>
        <mspace width="thinmathspace" />
        <mo>.</mo>
      </mstyle>
    </mrow>
    <annotation encoding="application/x-tex">{\displaystyle h(S(y),x_{1},\ldots ,x_{k})=g(y,h(y,x_{1},\ldots ,x_{k}),x_{1},\ldots ,x_{k})\,.}</annotation>
  </semantics>
</math></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/e88ae51d542a80531982719f8ae8581863b7b8a4" class="mwe-math-fallback-image-inline" aria-hidden="true" style="vertical-align: -0.838ex; width:54.207ex; height:2.843ex;" alt="h (S(y), x_1, \ldots, x_k) = g (y, h (y, x_1, \ldots, x_k), x_1, \ldots, x_k) \,."/></span></dd></dl></li></ol></div>
<p>Example. Suppose <i>f</i>(<i>x</i>) = <i>P</i><sub>1</sub><sup>1</sup>(<i>x</i>) = <i>x</i> and <i>g</i>(<i>x</i>,<i>y</i>,<i>z</i>)= <i>S</i>(<i>P</i><sub>2</sub><sup>3</sup>(<i>x</i>,<i>y</i>,<i>z</i>)) = <i>S</i>(<i>y</i>). Then <i>h</i>(0,<i>x</i>) = <i>x</i> and <i>h</i>(<i>S</i>(<i>y</i>),<i>x</i>) = <i>g</i>(<i>y</i>,<i>h</i>(<i>y</i>,<i>x</i>),<i>x</i>) = <i>S</i>(<i>h</i>(<i>y</i>,<i>x</i>)). Now <i>h</i>(0,1) = 1, <i>h</i>(1,1) = <i>S</i>(<i>h</i>(0,1)) = 2, <i>h</i>(2,1) = <i>S</i>(<i>h</i>(1,1)) = 3. This <i>h</i> is a 2-ary primitive recursive function. We can call it 'addition'.
</p><p>Interpretation. The function <i>h</i> acts as a <a href="/wiki/For_loop" title="For loop">for loop</a> from 0 up to the value of its first argument. The rest of the arguments for <i>h</i>, denoted here with <i>x</i><sub><i>i</i></sub>&#8217;s (<i>i</i> = 1, ..., <i>k</i>), are a set of initial conditions for the For loop which may be used by it during calculations but which are immutable by it. The functions <i>f</i> and <i>g</i> on the right side of the equations which define <i>h</i> represent the body of the loop, which performs calculations. Function <i>f</i> is only used once to perform initial calculations. Calculations for subsequent steps of the loop are performed by <i>g</i>. The first parameter of <i>g</i> is fed the &#8220;current&#8221; value of the For loop&#8217;s index. The second parameter of <i>g</i> is fed the result of the For loop&#8217;s previous calculations, from previous steps. The rest of the parameters for <i>g</i> are those immutable initial conditions for the For loop mentioned earlier. They may be used by <i>g</i> to perform calculations but they will not themselves be altered by <i>g</i>.
</p><p>The <b>primitive recursive</b> functions are the basic functions and those obtained from the basic functions by applying these operations a finite number of times.
</p>
<h3><span class="mw-headline" id="Role_of_the_projection_functions">Role of the projection functions</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Primitive_recursive_function&amp;action=edit&amp;section=2" title="Edit section: Role of the projection functions">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>The projection functions can be used to avoid the apparent rigidity in terms of the <a href="/wiki/Arity" title="Arity">arity</a> of the functions above; by using compositions with various projection functions, it is possible to pass a subset of the arguments of one function to another function.  For example, if <i>g</i> and <i>h</i> are 2-ary primitive recursive functions then
</p>
<dl><dd><span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math xmlns="http://www.w3.org/1998/Math/MathML"  alttext="{\displaystyle f(a,b,c)=g(h(c,a),h(a,b))\!}">
  <semantics>
    <mrow class="MJX-TeXAtom-ORD">
      <mstyle displaystyle="true" scriptlevel="0">
        <mi>f</mi>
        <mo stretchy="false">(</mo>
        <mi>a</mi>
        <mo>,</mo>
        <mi>b</mi>
        <mo>,</mo>
        <mi>c</mi>
        <mo stretchy="false">)</mo>
        <mo>=</mo>
        <mi>g</mi>
        <mo stretchy="false">(</mo>
        <mi>h</mi>
        <mo stretchy="false">(</mo>
        <mi>c</mi>
        <mo>,</mo>
        <mi>a</mi>
        <mo stretchy="false">)</mo>
        <mo>,</mo>
        <mi>h</mi>
        <mo stretchy="false">(</mo>
        <mi>a</mi>
        <mo>,</mo>
        <mi>b</mi>
        <mo stretchy="false">)</mo>
        <mo stretchy="false">)</mo>
        <mspace width="negativethinmathspace" />
      </mstyle>
    </mrow>
    <annotation encoding="application/x-tex">{\displaystyle f(a,b,c)=g(h(c,a),h(a,b))\!}</annotation>
  </semantics>
</math></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/4b69f3073cd3e396e0f348452611c5802fa56b22" class="mwe-math-fallback-image-inline" aria-hidden="true" style="vertical-align: -0.838ex; margin-right: -0.166ex; width:28.055ex; height:2.843ex;" alt="f(a,b,c) = g(h(c,a),h(a,b)) \!"/></span></dd></dl>
<p>is also primitive recursive.  One formal definition using projection functions is
</p>
<dl><dd><span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math xmlns="http://www.w3.org/1998/Math/MathML"  alttext="{\displaystyle f(a,b,c)=g(h(P_{3}^{3}(a,b,c),P_{1}^{3}(a,b,c)),h(P_{1}^{3}(a,b,c),P_{2}^{3}(a,b,c))).}">
  <semantics>
    <mrow class="MJX-TeXAtom-ORD">
      <mstyle displaystyle="true" scriptlevel="0">
        <mi>f</mi>
        <mo stretchy="false">(</mo>
        <mi>a</mi>
        <mo>,</mo>
        <mi>b</mi>
        <mo>,</mo>
        <mi>c</mi>
        <mo stretchy="false">)</mo>
        <mo>=</mo>
        <mi>g</mi>
        <mo stretchy="false">(</mo>
        <mi>h</mi>
        <mo stretchy="false">(</mo>
        <msubsup>
          <mi>P</mi>
          <mrow class="MJX-TeXAtom-ORD">
            <mn>3</mn>
          </mrow>
          <mrow class="MJX-TeXAtom-ORD">
            <mn>3</mn>
          </mrow>
        </msubsup>
        <mo stretchy="false">(</mo>
        <mi>a</mi>
        <mo>,</mo>
        <mi>b</mi>
        <mo>,</mo>
        <mi>c</mi>
        <mo stretchy="false">)</mo>
        <mo>,</mo>
        <msubsup>
          <mi>P</mi>
          <mrow class="MJX-TeXAtom-ORD">
            <mn>1</mn>
          </mrow>
          <mrow class="MJX-TeXAtom-ORD">
            <mn>3</mn>
          </mrow>
        </msubsup>
        <mo stretchy="false">(</mo>
        <mi>a</mi>
        <mo>,</mo>
        <mi>b</mi>
        <mo>,</mo>
        <mi>c</mi>
        <mo stretchy="false">)</mo>
        <mo stretchy="false">)</mo>
        <mo>,</mo>
        <mi>h</mi>
        <mo stretchy="false">(</mo>
        <msubsup>
          <mi>P</mi>
          <mrow class="MJX-TeXAtom-ORD">
            <mn>1</mn>
          </mrow>
          <mrow class="MJX-TeXAtom-ORD">
            <mn>3</mn>
          </mrow>
        </msubsup>
        <mo stretchy="false">(</mo>
        <mi>a</mi>
        <mo>,</mo>
        <mi>b</mi>
        <mo>,</mo>
        <mi>c</mi>
        <mo stretchy="false">)</mo>
        <mo>,</mo>
        <msubsup>
          <mi>P</mi>
          <mrow class="MJX-TeXAtom-ORD">
            <mn>2</mn>
          </mrow>
          <mrow class="MJX-TeXAtom-ORD">
            <mn>3</mn>
          </mrow>
        </msubsup>
        <mo stretchy="false">(</mo>
        <mi>a</mi>
        <mo>,</mo>
        <mi>b</mi>
        <mo>,</mo>
        <mi>c</mi>
        <mo stretchy="false">)</mo>
        <mo stretchy="false">)</mo>
        <mo stretchy="false">)</mo>
        <mo>.</mo>
      </mstyle>
    </mrow>
    <annotation encoding="application/x-tex">{\displaystyle f(a,b,c)=g(h(P_{3}^{3}(a,b,c),P_{1}^{3}(a,b,c)),h(P_{1}^{3}(a,b,c),P_{2}^{3}(a,b,c))).}</annotation>
  </semantics>
</math></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/33b5bb03a85bc434022458a3eede5b7d00e56ff4" class="mwe-math-fallback-image-inline" aria-hidden="true" style="vertical-align: -1.005ex; width:64.407ex; height:3.176ex;" alt="f(a,b,c) = g(h(P^3_3(a,b,c),P^3_1(a,b,c)),h(P^3_1(a,b,c),P^3_2(a,b,c)))."/></span></dd></dl>
<h3><span class="mw-headline" id="Converting_predicates_to_numeric_functions">Converting predicates to numeric functions</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Primitive_recursive_function&amp;action=edit&amp;section=3" title="Edit section: Converting predicates to numeric functions">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>In some settings it is natural to consider primitive recursive functions that take as inputs tuples that mix numbers with <a href="/wiki/Truth_value" title="Truth value">truth values</a> (that is <i>t</i> for true and <i>f</i> for false), or that produce truth values as outputs.<sup id="cite_ref-2" class="reference"><a href="#cite_note-2">&#91;2&#93;</a></sup> This can be accomplished by identifying the truth values with numbers in any fixed manner.  For example, it is common to identify the truth value <i>t</i> with the number 1 and the truth value <i>f</i> with the number 0.  Once this identification has been made, the <a href="/wiki/Indicator_function" title="Indicator function">characteristic function</a> of a set <i>A</i>, which always returns 1 or 0, can be viewed as a predicate that tells whether a number is in the set <i>A</i>.  Such an identification of predicates with numeric functions will be assumed for the remainder of this article.
</p>
<h3><span class="mw-headline" id="Computer_language_definition">Computer language definition</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Primitive_recursive_function&amp;action=edit&amp;section=4" title="Edit section: Computer language definition">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>An example of a primitive recursive programming language is one that contains basic arithmetic operators (e.g. + and −, or ADD and SUBTRACT), conditionals and comparison (IF-THEN, EQUALS, LESS-THAN), and bounded loops, such as the basic <a href="/wiki/For_loop" title="For loop">for loop</a>, where there is a known or calculable upper bound to all loops (FOR i FROM 1 TO n, with neither i nor n modifiable by the loop body). No control structures of greater generality, such as <a href="/wiki/While_loop" title="While loop">while loops</a> or IF-THEN plus <a href="/wiki/GOTO" class="mw-redirect" title="GOTO">GOTO</a>, are admitted in a primitive recursive language. <a href="/wiki/Douglas_Hofstadter" title="Douglas Hofstadter">Douglas Hofstadter</a>'s <a href="/wiki/BlooP_and_FlooP" title="BlooP and FlooP">BlooP</a> in <i><a href="/wiki/G%C3%B6del,_Escher,_Bach" title="Gödel, Escher, Bach">Gödel, Escher, Bach</a></i> is such a language.  Adding unbounded loops (WHILE, GOTO) makes the language partially recursive, or <a href="/wiki/Turing_completeness" title="Turing completeness">Turing-complete</a>; Floop is an example, as are almost all real-world computer programming languages.
</p><p>Arbitrary computer programs, or <a href="/wiki/Turing_machine" title="Turing machine">Turing machines</a>, cannot in general be analyzed to see if they halt or not (the <a href="/wiki/Halting_problem" title="Halting problem">halting problem</a>).  However, all primitive recursive functions halt. This is not a contradiction; primitive recursive programs are a non-arbitrary subset of all possible programs, constructed specifically to be analyzable.
</p>
<h2><span class="mw-headline" id="Examples">Examples</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Primitive_recursive_function&amp;action=edit&amp;section=5" title="Edit section: Examples">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Most number-theoretic functions definable using <a href="/wiki/Recursion_(computer_science)" title="Recursion (computer science)">recursion</a> on a single variable are primitive recursive.  Basic examples include the addition and <a href="/wiki/Truncated_subtraction" class="mw-redirect" title="Truncated subtraction">truncated subtraction</a> functions.
</p>
<h3><span class="mw-headline" id="Addition">Addition</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Primitive_recursive_function&amp;action=edit&amp;section=6" title="Edit section: Addition">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>Intuitively, addition can be recursively defined with the rules:
</p>
<dl><dd><span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math xmlns="http://www.w3.org/1998/Math/MathML"  alttext="{\displaystyle add(0,x)=x}">
  <semantics>
    <mrow class="MJX-TeXAtom-ORD">
      <mstyle displaystyle="true" scriptlevel="0">
        <mi>a</mi>
        <mi>d</mi>
        <mi>d</mi>
        <mo stretchy="false">(</mo>
        <mn>0</mn>
        <mo>,</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
        <mo>=</mo>
        <mi>x</mi>
      </mstyle>
    </mrow>
    <annotation encoding="application/x-tex">{\displaystyle add(0,x)=x}</annotation>
  </semantics>
</math></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/f558b39e574a49ec076fff81f43dd740ffe70f2b" class="mwe-math-fallback-image-inline" aria-hidden="true" style="vertical-align: -0.838ex; width:13.425ex; height:2.843ex;" alt="{\displaystyle add(0,x)=x}"/></span>,</dd>
<dd><span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math xmlns="http://www.w3.org/1998/Math/MathML"  alttext="{\displaystyle add(n+1,x)=add(n,x)+1}">
  <semantics>
    <mrow class="MJX-TeXAtom-ORD">
      <mstyle displaystyle="true" scriptlevel="0">
        <mi>a</mi>
        <mi>d</mi>
        <mi>d</mi>
        <mo stretchy="false">(</mo>
        <mi>n</mi>
        <mo>+</mo>
        <mn>1</mn>
        <mo>,</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
        <mo>=</mo>
        <mi>a</mi>
        <mi>d</mi>
        <mi>d</mi>
        <mo stretchy="false">(</mo>
        <mi>n</mi>
        <mo>,</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
        <mo>+</mo>
        <mn>1</mn>
      </mstyle>
    </mrow>
    <annotation encoding="application/x-tex">{\displaystyle add(n+1,x)=add(n,x)+1}</annotation>
  </semantics>
</math></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/10e9109bb677f19efc2cfd73cfa3dda729d1a97a" class="mwe-math-fallback-image-inline" aria-hidden="true" style="vertical-align: -0.838ex; width:29.563ex; height:2.843ex;" alt="{\displaystyle add(n+1,x)=add(n,x)+1}"/></span></dd></dl>
<p>To fit this into a strict primitive recursive definition, define:
</p>
<dl><dd><span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math xmlns="http://www.w3.org/1998/Math/MathML"  alttext="{\displaystyle add(0,x)=P_{1}^{1}(x),}">
  <semantics>
    <mrow class="MJX-TeXAtom-ORD">
      <mstyle displaystyle="true" scriptlevel="0">
        <mi>a</mi>
        <mi>d</mi>
        <mi>d</mi>
        <mo stretchy="false">(</mo>
        <mn>0</mn>
        <mo>,</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
        <mo>=</mo>
        <msubsup>
          <mi>P</mi>
          <mrow class="MJX-TeXAtom-ORD">
            <mn>1</mn>
          </mrow>
          <mrow class="MJX-TeXAtom-ORD">
            <mn>1</mn>
          </mrow>
        </msubsup>
        <mo stretchy="false">(</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
        <mo>,</mo>
      </mstyle>
    </mrow>
    <annotation encoding="application/x-tex">{\displaystyle add(0,x)=P_{1}^{1}(x),}</annotation>
  </semantics>
</math></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/6e038540f0ebfd500696ba8c61c7249972a77382" class="mwe-math-fallback-image-inline" aria-hidden="true" style="vertical-align: -1.005ex; width:18.757ex; height:3.176ex;" alt="{\displaystyle add(0,x)=P_{1}^{1}(x),}"/></span></dd>
<dd><span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math xmlns="http://www.w3.org/1998/Math/MathML"  alttext="{\displaystyle add(S(n),x)=S(P_{2}^{3}(n,add(n,x),x))}">
  <semantics>
    <mrow class="MJX-TeXAtom-ORD">
      <mstyle displaystyle="true" scriptlevel="0">
        <mi>a</mi>
        <mi>d</mi>
        <mi>d</mi>
        <mo stretchy="false">(</mo>
        <mi>S</mi>
        <mo stretchy="false">(</mo>
        <mi>n</mi>
        <mo stretchy="false">)</mo>
        <mo>,</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
        <mo>=</mo>
        <mi>S</mi>
        <mo stretchy="false">(</mo>
        <msubsup>
          <mi>P</mi>
          <mrow class="MJX-TeXAtom-ORD">
            <mn>2</mn>
          </mrow>
          <mrow class="MJX-TeXAtom-ORD">
            <mn>3</mn>
          </mrow>
        </msubsup>
        <mo stretchy="false">(</mo>
        <mi>n</mi>
        <mo>,</mo>
        <mi>a</mi>
        <mi>d</mi>
        <mi>d</mi>
        <mo stretchy="false">(</mo>
        <mi>n</mi>
        <mo>,</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
        <mo>,</mo>
        <mi>x</mi>
        <mo stretchy="false">)</mo>
        <mo stretchy="false">)</mo>
      </mstyle>
    </mrow>
    <annotation encoding="application/x-tex">{\displaystyle add(S(n),x)=S(P_{2}^{3}(n,add(n,x),x))}</annotation>
  </semantics>
</math></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/cc922f73ef0107021159ed506052626ceec47c43" class="mwe-math-fallback-image-inline" aria-hidden="true" style="vertical-align: -1.005ex; width:37.651ex; height:3.176ex;" alt="{\displaystyle add(S(n),x)=S(P_{2}^{3}(n,add(n,x),x))}"/></span></dd></dl>
<p>Here S(<i>n</i>) is "the successor of <i>n</i>" (i.e., <i>n</i>+1), <i>P</i><sub>1</sub><sup>1</sup> is the <a href="/wiki/Identity_function" title="Identity function">identity function</a>, and <i>P</i><sub>2</sub><sup>3</sup> is the <a href="/wiki/Projection_function" class="mw-redirect" title="Projection function">projection function</a> that takes 3 arguments and returns the second one. Functions <i>f</i> and <i>g</i> required by the above definition of the primitive recursion operation are respectively played by <i>P</i><sub>1</sub><sup>1</sup> and the composition of <i>S</i> and <i>P</i><sub>2</sub><sup>3</sup>.
</p>
<h3><span class="mw-headline" id="Subtraction">Subtraction</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Primitive_recursive_function&amp;action=edit&amp;section=7" title="Edit section: Subtraction">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<div role="note" class="hatnote navigation-not-searchable">See also: <a href="/wiki/Monus" title="Monus">Monus</a></div>
<p>Because primitive recursive functions use natural numbers rather than integers, and the natural numbers are not closed under subtraction, a truncated subtraction function (also called "proper subtraction") is studied in this context. This limited subtraction function sub(<i>a</i>, <i>b</i>) [or <i>b</i> ∸ <i>a</i>] returns <i>b</i> - <i>a</i> if this is nonnegative and returns <i>0</i> otherwise.
</p><p>The <b>predecessor function</b> acts as the opposite of the successor function and is recursively defined by the rules:
</p>
<dl><dd>pred(0) = 0,</dd>
<dd>pred(<i>n</i> + 1) = <i>n</i>.</dd></dl>
<p>These rules can be converted into a more formal definition by primitive recursion:
</p>
<dl><dd>pred(0) = 0,</dd>
<dd>pred(S(<i>n</i>)) = <i>P</i><sub>1</sub><sup>2</sup>(<i>n</i>, pred(<i>n</i>)).</dd></dl>
<p>The limited subtraction function is definable from the predecessor function in a manner analogous to the way addition is defined from successor:
</p>
<dl><dd>sub(0, <i>x</i>) = <i>P</i><sub>1</sub><sup>1</sup>(<i>x</i>),</dd>
<dd>sub(S(<i>n</i>), <i>x</i>) = pred(<i>P</i><sub>2</sub><sup>3</sup>(<i>n</i>, sub(<i>n</i>, <i>x</i>), <i>x</i>)).</dd></dl>
<p>Here sub(<i>a</i>,  <i>b</i>) corresponds to <i>b</i> ∸ <i>a</i>; for the sake of simplicity, the order of the arguments has been switched from the "standard" definition to fit the requirements of primitive recursion. This could easily be rectified using composition with suitable projections.
</p>
<h3><span class="mw-headline" id="Other_operations_on_natural_numbers">Other operations on natural numbers</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Primitive_recursive_function&amp;action=edit&amp;section=8" title="Edit section: Other operations on natural numbers">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p><a href="/wiki/Exponentiation" title="Exponentiation">Exponentiation</a> and <a href="/wiki/Primality_test" title="Primality test">primality testing</a> are primitive recursive. Given primitive recursive functions <i>e</i>, <i>f</i>, <i>g</i>, and <i>h</i>, a function that returns the value of <i>g</i> when <i>e</i>≤<i>f</i> and the value of <i>h</i> otherwise is primitive recursive.
</p>
<h3><span class="mw-headline" id="Operations_on_integers_and_rational_numbers">Operations on integers and rational numbers</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Primitive_recursive_function&amp;action=edit&amp;section=9" title="Edit section: Operations on integers and rational numbers">edit</a><span class="mw-editsection-bracket">]</span></span></h3>
<p>By using <a href="/wiki/G%C3%B6del_numbering" title="Gödel numbering">Gödel numberings</a>, the primitive recursive functions can be extended to operate on other objects such as integers and <a href="/wiki/Rational_number" title="Rational number">rational numbers</a>.  If integers are encoded by Gödel numbers in a standard way, the arithmetic operations including addition, subtraction, and multiplication are all primitive recursive.  Similarly, if the rationals are represented by Gödel numbers then the <a href="/wiki/Field_(mathematics)" title="Field (mathematics)">field</a> operations are all primitive recursive.
</p>
<h2><span class="mw-headline" id="Use_in_first-order_Peano_arithmetic">Use in first-order Peano arithmetic</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Primitive_recursive_function&amp;action=edit&amp;section=10" title="Edit section: Use in first-order Peano arithmetic">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>In <a href="/wiki/First-order_logic" title="First-order logic">first-order</a> <a href="/wiki/Peano_arithmetic" class="mw-redirect" title="Peano arithmetic">Peano arithmetic</a>, there are infinitely many variables (0-ary symbols) but no <a href="/wiki/Arity" title="Arity">k-ary</a> non-logical symbols with k&gt;0 other than S, +, *, and ≤. Thus in order to define primitive recursive functions one has to use the following trick by Gödel.
</p><p>By using a <a href="/wiki/G%C3%B6del_numbering_for_sequences" title="Gödel numbering for sequences">Gödel numbering for sequences</a>, for example <a href="/wiki/G%C3%B6del%27s_%CE%B2_function" title="Gödel&#39;s β function">Gödel's β function</a>, any finite sequence of numbers can be encoded by a single number. Such a number can therefore represent the primitive recursive function until a given n.
</p><p>Let <i>h</i> be a 1-ary primitive recursion function defined by:
</p>
<dl><dd><span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math xmlns="http://www.w3.org/1998/Math/MathML"  alttext="{\displaystyle h(0)=C}">
  <semantics>
    <mrow class="MJX-TeXAtom-ORD">
      <mstyle displaystyle="true" scriptlevel="0">
        <mi>h</mi>
        <mo stretchy="false">(</mo>
        <mn>0</mn>
        <mo stretchy="false">)</mo>
        <mo>=</mo>
        <mi>C</mi>
      </mstyle>
    </mrow>
    <annotation encoding="application/x-tex">{\displaystyle h(0)=C}</annotation>
  </semantics>
</math></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/34578357676bace61816b904e59f25d444c044c3" class="mwe-math-fallback-image-inline" aria-hidden="true" style="vertical-align: -0.838ex; width:9.176ex; height:2.843ex;" alt="{\displaystyle h(0)=C}"/></span></dd>
<dd><span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math xmlns="http://www.w3.org/1998/Math/MathML"  alttext="{\displaystyle h(n+1)=g(n,h(n))}">
  <semantics>
    <mrow class="MJX-TeXAtom-ORD">
      <mstyle displaystyle="true" scriptlevel="0">
        <mi>h</mi>
        <mo stretchy="false">(</mo>
        <mi>n</mi>
        <mo>+</mo>
        <mn>1</mn>
        <mo stretchy="false">)</mo>
        <mo>=</mo>
        <mi>g</mi>
        <mo stretchy="false">(</mo>
        <mi>n</mi>
        <mo>,</mo>
        <mi>h</mi>
        <mo stretchy="false">(</mo>
        <mi>n</mi>
        <mo stretchy="false">)</mo>
        <mo stretchy="false">)</mo>
      </mstyle>
    </mrow>
    <annotation encoding="application/x-tex">{\displaystyle h(n+1)=g(n,h(n))}</annotation>
  </semantics>
</math></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/73265fa3c6c0e57ffe6820f2510674930b35eb01" class="mwe-math-fallback-image-inline" aria-hidden="true" style="vertical-align: -0.838ex; width:21.541ex; height:2.843ex;" alt="{\displaystyle h(n+1)=g(n,h(n))}"/></span></dd></dl>
<p>where C is a constant and <i>g</i> is an already defined function.
</p><p>Using Gödel's β function, for any sequence of natural numbers (k<sub>0</sub>, k<sub>1</sub>, …, k<sub>n</sub>), there are natural numbers b and c such that, for every i ≤ n, β(b, c, i) = k<sub>i</sub>. We may thus use the following formula to define <i>h</i>; more precisely, <i>m</i>=<i>h</i>(<i>n</i>) is a shorthand for the following:
</p>
<dl><dd><span class="mwe-math-element"><span class="mwe-math-mathml-inline mwe-math-mathml-a11y" style="display: none;"><math xmlns="http://www.w3.org/1998/Math/MathML"  alttext="{\displaystyle \exists b:\exists c:\beta (b,c,0)=C\land \forall i:(i&lt;n)\rightarrow (\beta (b,c,i+1)=g(i,\beta (b,c,i)))\land (m=\beta (b,c,n))}">
  <semantics>
    <mrow class="MJX-TeXAtom-ORD">
      <mstyle displaystyle="true" scriptlevel="0">
        <mi mathvariant="normal">&#x2203;<!-- ∃ --></mi>
        <mi>b</mi>
        <mo>:</mo>
        <mi mathvariant="normal">&#x2203;<!-- ∃ --></mi>
        <mi>c</mi>
        <mo>:</mo>
        <mi>&#x03B2;<!-- β --></mi>
        <mo stretchy="false">(</mo>
        <mi>b</mi>
        <mo>,</mo>
        <mi>c</mi>
        <mo>,</mo>
        <mn>0</mn>
        <mo stretchy="false">)</mo>
        <mo>=</mo>
        <mi>C</mi>
        <mo>&#x2227;<!-- ∧ --></mo>
        <mi mathvariant="normal">&#x2200;<!-- ∀ --></mi>
        <mi>i</mi>
        <mo>:</mo>
        <mo stretchy="false">(</mo>
        <mi>i</mi>
        <mo>&lt;</mo>
        <mi>n</mi>
        <mo stretchy="false">)</mo>
        <mo stretchy="false">&#x2192;<!-- → --></mo>
        <mo stretchy="false">(</mo>
        <mi>&#x03B2;<!-- β --></mi>
        <mo stretchy="false">(</mo>
        <mi>b</mi>
        <mo>,</mo>
        <mi>c</mi>
        <mo>,</mo>
        <mi>i</mi>
        <mo>+</mo>
        <mn>1</mn>
        <mo stretchy="false">)</mo>
        <mo>=</mo>
        <mi>g</mi>
        <mo stretchy="false">(</mo>
        <mi>i</mi>
        <mo>,</mo>
        <mi>&#x03B2;<!-- β --></mi>
        <mo stretchy="false">(</mo>
        <mi>b</mi>
        <mo>,</mo>
        <mi>c</mi>
        <mo>,</mo>
        <mi>i</mi>
        <mo stretchy="false">)</mo>
        <mo stretchy="false">)</mo>
        <mo stretchy="false">)</mo>
        <mo>&#x2227;<!-- ∧ --></mo>
        <mo stretchy="false">(</mo>
        <mi>m</mi>
        <mo>=</mo>
        <mi>&#x03B2;<!-- β --></mi>
        <mo stretchy="false">(</mo>
        <mi>b</mi>
        <mo>,</mo>
        <mi>c</mi>
        <mo>,</mo>
        <mi>n</mi>
        <mo stretchy="false">)</mo>
        <mo stretchy="false">)</mo>
      </mstyle>
    </mrow>
    <annotation encoding="application/x-tex">{\displaystyle \exists b:\exists c:\beta (b,c,0)=C\land \forall i:(i&lt;n)\rightarrow (\beta (b,c,i+1)=g(i,\beta (b,c,i)))\land (m=\beta (b,c,n))}</annotation>
  </semantics>
</math></span><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/39f0f9f168ce7cb1cba2a0944584a3469f39c3b4" class="mwe-math-fallback-image-inline" aria-hidden="true" style="vertical-align: -0.838ex; width:86.882ex; height:2.843ex;" alt="{\displaystyle \exists b:\exists c:\beta (b,c,0)=C\land \forall i:(i&lt;n)\rightarrow (\beta (b,c,i+1)=g(i,\beta (b,c,i)))\land (m=\beta (b,c,n))}"/></span></dd></dl>
<p>and the equating to <i>g</i>, being already defined, is in fact shorthand for some other already defined formula (as is β, whose formula is given <a href="/wiki/G%C3%B6del%27s_%CE%B2_function" title="Gödel&#39;s β function">here</a>).
</p><p>The generalization to any k-ary primitive recursion function is trivial.
</p>
<h2><span class="mw-headline" id="Relationship_to_recursive_functions">Relationship to recursive functions</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Primitive_recursive_function&amp;action=edit&amp;section=11" title="Edit section: Relationship to recursive functions">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>The broader class of <a href="/wiki/Partial_recursive_function" class="mw-redirect" title="Partial recursive function">partial recursive functions</a> is defined by introducing an <a href="/wiki/Mu_operator" class="mw-redirect" title="Mu operator">unbounded search operator</a>.  The use of this operator may result in a <a href="/wiki/Partial_function" title="Partial function">partial function</a>, that is, a relation with <i>at most</i> one value for each argument, but does not necessarily have <i>any</i> value for any argument (see <a href="/wiki/Domain_of_a_function" title="Domain of a function">domain</a>).  An equivalent definition states that a partial recursive function is one that can be computed by a <a href="/wiki/Turing_machine" title="Turing machine">Turing machine</a>.  A total recursive function is a partial recursive function that is defined for every input.
</p><p>Every primitive recursive function is total recursive, but not all total recursive functions are primitive recursive. The <a href="/wiki/Ackermann_function" title="Ackermann function">Ackermann function</a> <i>A</i>(<i>m</i>,<i>n</i>) is a well-known example of a total recursive function (in fact, provable total), that is not primitive recursive. There is a characterization of the primitive recursive functions as a subset of the total recursive functions using the Ackermann function.  This characterization states that a function is primitive recursive <a href="/wiki/If_and_only_if" title="If and only if">if and only if</a> there is a natural number <i>m</i> such that the function can be computed by a Turing <a href="/wiki/Machine_that_always_halts" title="Machine that always halts">machine that always halts</a> within A(<i>m</i>,<i>n</i>) or fewer steps, where <i>n</i> is the sum of the arguments of the primitive recursive function.<sup id="cite_ref-3" class="reference"><a href="#cite_note-3">&#91;3&#93;</a></sup>
</p><p>An important property of the primitive recursive functions is that they are a <a href="/wiki/Recursively_enumerable" class="mw-redirect" title="Recursively enumerable">recursively enumerable</a> subset of the set of all <a href="/wiki/Total_recursive_function" class="mw-redirect" title="Total recursive function">total recursive functions</a> (which is not itself recursively enumerable). This means that there is a single computable function <i>f</i>(<i>m</i>,<i>n</i>) that enumerates the primitive recursive functions, namely:
</p>
<ul><li>For every primitive recursive function <i>g</i>, there is an <i>m</i> such that <i>g</i>(<i>n</i>) = <i>f</i>(<i>m</i>,<i>n</i>) for all <i>n</i>, and</li>
<li>For every <i>m</i>, the function <i>h</i>(<i>n</i>) = <i>f</i>(<i>m</i>,<i>n</i>) is primitive recursive.</li></ul>
<p><i>f</i> can be explicitly constructed by iteratively repeating all possible ways of creating primitive recursive functions. Thus, it is provably total. One can use a <a href="/wiki/Diagonal_lemma" title="Diagonal lemma">diagonalization</a> argument to show that <i>f</i> is not recursive primitive in itself: had it been such, so would be <i>h</i>(<i>n</i>) = <i>f</i>(<i>n</i>,<i>n</i>)+1. But if this equals some primitive recursive function, there is an <i>m</i> such that <i>h</i>(<i>n</i>) = <i>f</i>(<i>m</i>,<i>n</i>) for all <i>n</i>, and then <i>h</i>(<i>m</i>) = <i>f</i>(<i>m</i>,<i>m</i>), leading to contradiction.
</p><p>However, the set of primitive recursive functions is not the <i>largest</i> recursively enumerable subset of the set of all total recursive functions. For example, the set of provably total functions (in Peano arithmetic) is also recursively enumerable, as one can enumerate all the proofs of the theory. While all primitive recursive functions are provably total, the converse is not true.
</p>
<h2><span class="mw-headline" id="Limitations">Limitations</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Primitive_recursive_function&amp;action=edit&amp;section=12" title="Edit section: Limitations">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Primitive recursive functions tend to correspond very closely with our intuition of what a computable function must be. Certainly the initial functions are intuitively computable (in their very simplicity), and the two operations by which one can create new primitive recursive functions are also very straightforward. However, the set of primitive recursive functions does not include every possible total computable function—this can be seen with a variant of <a href="/wiki/Cantor%27s_diagonal_argument" title="Cantor&#39;s diagonal argument">Cantor's diagonal argument</a>. This argument provides a total computable function that is not primitive recursive. A sketch of the proof is as follows:
</p>
<div style="padding-left: 3em; padding-right:0em; overflow: hidden;">The primitive recursive functions of one argument (i.e., unary functions) can be <a href="/wiki/Recursively_enumerable_set" title="Recursively enumerable set">computably enumerated</a>. This enumeration uses the definitions of the primitive recursive functions (which are essentially just expressions with the composition and primitive recursion operations as operators and the basic primitive recursive functions as atoms), and can be assumed to contain every definition once, even though a same <i>function</i> will occur many times on the list (since many definitions define the same function; indeed simply composing by the <a href="/wiki/Identity_function" title="Identity function">identity function</a> generates infinitely many definitions of any one primitive recursive function). This means that the <span class="texhtml mvar" style="font-style:italic;"><i>n</i></span>-th definition of a primitive recursive function in this enumeration can be effectively determined from <span class="texhtml mvar" style="font-style:italic;"><i>n</i></span>. Indeed if one uses some <a href="/wiki/G%C3%B6del_numbering" title="Gödel numbering">Gödel numbering</a> to encode definitions as numbers, then this <span class="texhtml mvar" style="font-style:italic;"><i>n</i></span>-th definition in the list is computed by a primitive recursive function of <span class="texhtml mvar" style="font-style:italic;"><i>n</i></span>. Let <span class="texhtml"><i>f</i><sub><i>n</i></sub></span> denote the unary primitive recursive function given by this definition.
<p>Now define the "evaluator function" <span class="texhtml mvar" style="font-style:italic;"><i>ev</i></span> with two arguments, by <span class="texhtml"><i>ev</i>(<i>i</i>,<i>j</i>) = <i>f</i><sub><i>i</i></sub>(<i>j</i>)</span>. Clearly <span class="texhtml"><i>ev</i></span> is total and computable, since one can effectively determine the definition of <span class="texhtml"><i>f</i><sub><i>i</i></sub></span>, and being a primitive recursive function <span class="texhtml"><i>f</i><sub><i>i</i></sub></span> is itself total and computable, so <span class="texhtml"><i>f</i><sub><i>i</i></sub>(<i>j</i>)</span> is always defined and effectively computable. However a diagonal argument will show that the function <span class="texhtml mvar" style="font-style:italic;"><i>ev</i></span> of two arguments is not primitive recursive.
</p>
Suppose <span class="texhtml mvar" style="font-style:italic;"><i>ev</i></span> were primitive recursive, then the unary function <span class="texhtml mvar" style="font-style:italic;"><i>g</i></span> defined by <span class="texhtml"><i>g</i>(<i>i</i>) = S(<i>ev</i>(<i>i</i>,<i>i</i>))</span> would also be primitive recursive, as it is defined by composition from the successor function and <span class="texhtml mvar" style="font-style:italic;"><i>ev</i></span>. But then <span class="texhtml mvar" style="font-style:italic;"><i>g</i></span> occurs in the enumeration, so there is some number <span class="texhtml mvar" style="font-style:italic;"><i>n</i></span> such that <span class="texhtml"><i>g</i> = <i>f</i><sub><i>n</i></sub></span>. But now <span class="texhtml"><i>g</i>(<i>n</i>) = S(<i>ev</i>(<i>n</i>,<i>n</i>)) = S(<i>f</i><sub><i>n</i></sub>(<i>n</i>)) = S(<i>g</i>(<i>n</i>))</span> gives a contradiction.</div>
<p>This argument can be applied to any class of computable (total) functions that can be enumerated in this way, as explained in the article <a href="/wiki/Machine_that_always_halts" title="Machine that always halts">Machine that always halts</a>. Note however that the <i>partial</i> computable functions (those that need not be defined for all arguments) can be explicitly enumerated, for instance by enumerating Turing machine encodings.
</p><p>Other examples of total recursive but not primitive recursive functions are known:
</p>
<ul><li>The function that takes <i>m</i> to <a href="/wiki/Ackermann_function" title="Ackermann function">Ackermann</a>(<i>m</i>,<i>m</i>) is a unary total recursive function that is not primitive recursive.</li>
<li>The <a href="/wiki/Paris%E2%80%93Harrington_theorem" title="Paris–Harrington theorem">Paris–Harrington theorem</a> involves a total recursive function that is not primitive recursive.  Because this function is motivated by <a href="/wiki/Ramsey_theory" title="Ramsey theory">Ramsey theory</a>, it is sometimes considered more "natural" than the Ackermann function.</li>
<li>The <a href="/wiki/Sudan_function" title="Sudan function">Sudan function</a></li>
<li>The <a href="/wiki/Goodstein_function" class="mw-redirect" title="Goodstein function">Goodstein function</a></li></ul>
<h2><span class="mw-headline" id="Some_common_primitive_recursive_functions">Some common primitive recursive functions</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Primitive_recursive_function&amp;action=edit&amp;section=13" title="Edit section: Some common primitive recursive functions">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<dl><dd>The following examples and definitions are from Kleene (1952) pp.&#160;223–231 — many appear with proofs. Most also appear with similar names, either as proofs or as examples, in Boolos-Burgess-Jeffrey 2002 pp.&#160;63–70; they add #22 the logarithm lo(x, y) or lg(x, y) depending on the exact derivation.</dd></dl>
<p>In the following we observe that primitive recursive functions can be of four types:
</p>
<ol><li><i>functions</i> for short: "number-theoretic functions" from { 0, 1, 2, ...} to { 0, 1, 2, ...},</li>
<li><i>predicates</i>: from { 0, 1, 2, ...} to truth values { t =true, f =false },</li>
<li><i>propositional connectives</i>: from truth values { t, f } to truth values { t, f },</li>
<li><i>representing functions</i>: from truth values { t, f } to { 0, 1, 2, ... }. Many times a predicate requires a representing function to convert the predicate's output { t, f } to { 0, 1 } (note the order "t" to "0" and "f" to "1" matches with ~sg( ) defined below). By definition a function φ(<b>x</b>) is a "representing function" of the predicate P(<b>x</b>) if φ takes only values 0 and 1 and produces <i>0</i> when P is true".</li></ol>
<p>In the following the mark " ' ", e.g. a', is the primitive mark meaning "the successor of", usually thought of as " +1", e.g. a +1 =<sub>def</sub> a'. The functions 16-20 and #G are of particular interest with respect to converting primitive recursive predicates to, and extracting them from, their "arithmetical" form expressed as <a href="/wiki/G%C3%B6del_number" class="mw-redirect" title="Gödel number">Gödel numbers</a>.
</p>
<dl><dd><ol><li>Addition: a+b</li>
<li>Multiplication: a×b</li>
<li>Exponentiation: a<sup>b</sup></li>
<li>Factorial a!&#160;: 0! = 1, a'! = a!×a'</li>
<li>pred(a): (Predecessor or decrement): If a &gt; 0 then a-1 else 0</li>
<li>Proper subtraction a ∸ b: If a ≥ b then a-b else 0</li>
<li>Minimum(a<sub>1</sub>, ... a<sub>n</sub>)</li>
<li>Maximum(a<sub>1</sub>, ... a<sub>n</sub>)</li>
<li>Absolute difference: | a-b | =<sub>def</sub> (a ∸ b) + (b ∸ a)</li>
<li>~sg(a): NOT[signum(a)]: If a=0 then 1 else 0</li>
<li>sg(a): signum(a): If a=0 then 0 else 1</li>
<li>a | b: (a divides b): If b=k×a for some k then 0 else 1</li>
<li>Remainder(a, b): the leftover if b does not divide a "evenly".  Also called MOD(a, b)</li>
<li>a = b: sg | a - b |  (Kleene's convention was to represent <i>true</i> by 0 and <i>false</i> by 1; presently, especially in computers, the most common convention is the reverse, namely to represent <i>true</i> by 1 and <i>false</i> by 0, which amounts to changing sg into ~sg here and in the next item)</li>
<li>a &lt; b: sg( a' ∸ b )</li>
<li>Pr(a): a is a prime number Pr(a) =<sub>def</sub>  a&gt;1 &amp; NOT(Exists c)<sub>1&lt;c&lt;a</sub> [ c|a ]</li>
<li>p<sub>i</sub>: the i+1-st prime number</li>
<li>(a)<sub>i</sub>: exponent of p<sub>i</sub> in a: the unique x such that p<sub>i</sub><sup>x</sup>|a &amp; NOT(p<sub>i</sub><sup>x'</sup>|a)</li>
<li>lh(a): the "length" or number of non-vanishing exponents in a</li>
<li>lo(a, b): logarithm of a to the base b</li></ol></dd></dl>
<dl><dd><i>In the following, the abbreviation <b>x</b> =<sub>def</sub>  x<sub>1</sub>, ... x<sub>n</sub>; subscripts may be applied if the meaning requires.</i></dd></dl>
<ul><li>#A:  A function φ definable explicitly from functions Ψ and constants q<sub>1</sub>, ... q<sub>n</sub> is primitive recursive in Ψ.</li>
<li>#B:  The finite sum Σ<sub>y&lt;z</sub> ψ(<b>x</b>, y) and product Π<sub>y&lt;z</sub>ψ(<b>x</b>, y) are primitive recursive in ψ.</li>
<li>#C:  A <i>predicate</i> P obtained by substituting functions χ<sub>1</sub>,..., χ<sub>m</sub> for the respective variables of a predicate Q is primitive recursive in χ<sub>1</sub>,..., χ<sub>m</sub>, Q.</li>
<li>#D:  The following <i>predicates</i> are primitive recursive in Q and R:</li></ul>
<dl><dd><dl><dd><ul><li>NOT_Q(<b>x</b>) .</li>
<li>Q OR R: Q(<b>x</b>) V R(<b>x</b>),</li>
<li>Q AND R: Q(<b>x</b>) &amp; R(<b>x</b>),</li>
<li>Q IMPLIES R: Q(<b>x</b>) → R(<b>x</b>)</li>
<li>Q is equivalent to R: Q(<b>x</b>) ≡ R(<b>x</b>)</li></ul></dd></dl></dd></dl>
<ul><li>#E:  The following <i>predicates</i> are primitive recursive in the <i>predicate</i> R:</li></ul>
<dl><dd><dl><dd><ul><li>(Ey)<sub>y&lt;z</sub> R(<b>x</b>, y) where (Ey)<sub>y&lt;z</sub> denotes "there exists at least one y that is less than z such that"</li>
<li>(y)<sub>y&lt;z</sub> R(<b>x</b>, y) where (y)<sub>y&lt;z</sub> denotes "for all y less than z it is true that"</li>
<li>μy<sub>y&lt;z</sub> R(<b>x</b>, y).  The operator μy<sub>y&lt;z</sub> R(<b>x</b>, y) is a <i>bounded</i> form of the so-called minimization- or <a href="/wiki/Mu-operator" class="mw-redirect" title="Mu-operator">mu-operator</a>: Defined as "the least value of y less than z such that R(<b>x</b>, y) is true; or z if there is no such value."</li></ul></dd></dl></dd></dl>
<ul><li>#F:  Definition by cases: The function defined thus, where Q<sub>1</sub>, ..., Q<sub>m</sub> are mutually exclusive <i>predicates</i> (or "ψ(<b>x</b>) shall have the value given by the first clause that applies), is primitive recursive in φ<sub>1</sub>, ..., Q<sub>1</sub>, ... Q<sub>m</sub>:</li></ul>
<dl><dd><dl><dd>φ(<b>x</b>) =
<ul><li>φ<sub>1</sub>(<b>x</b>) if Q<sub>1</sub>(<b>x</b>) is true,</li>
<li>.  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .</li>
<li>φ<sub>m</sub>(<b>x</b>) if Q<sub>m</sub>(<b>x</b>) is true</li>
<li>φ<sub>m+1</sub>(<b>x</b>) otherwise</li></ul></dd></dl></dd></dl>
<ul><li>#G: If φ satisfies the equation:</li></ul>
<dl><dd><dl><dd>φ(y,<b>x</b>) = χ(y, NOT-φ(y; x<sub>2</sub>, ... x<sub>n</sub> ), x<sub>2</sub>, ... x<sub>n</sub> then φ is primitive recursive in χ. 'So, in a sense the knowledge of the value NOT-φ(y; <b>x</b><sub>2 to n</sub> ) of the course-of-values function is equivalent to the knowledge of the sequence of values φ(0,<b>x</b><sub>2 to n</sub>), ..., φ(y-1,<b>x</b><sub>2 to n</sub>) of the original function."</dd></dl></dd></dl>
<h2><span class="mw-headline" id="Additional_primitive_recursive_forms">Additional primitive recursive forms</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Primitive_recursive_function&amp;action=edit&amp;section=14" title="Edit section: Additional primitive recursive forms">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>Some additional forms of recursion also define functions that are in fact
primitive recursive.  Definitions in these forms may be easier to find or
more natural for reading or writing. <a href="/wiki/Course-of-values_recursion" title="Course-of-values recursion">Course-of-values recursion</a> defines primitive recursive functions. Some forms of <a href="/wiki/Mutual_recursion" title="Mutual recursion">mutual recursion</a> also define primitive recursive functions.
</p><p>The functions that can be programmed in the <a href="/wiki/LOOP_(programming_language)" title="LOOP (programming language)">LOOP programming language</a> are exactly the primitive recursive functions. This gives a different characterization of the power of these functions. The main limitation of the LOOP language, compared to a <a href="/wiki/Turing-complete_language" class="mw-redirect" title="Turing-complete language">Turing-complete language</a>, is that in the LOOP language the number of times that each loop will run is specified before the loop begins to run.
</p>
<h2><span class="mw-headline" id="Finitism_and_consistency_results">Finitism and consistency results</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Primitive_recursive_function&amp;action=edit&amp;section=15" title="Edit section: Finitism and consistency results">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p>The primitive recursive functions are closely related to mathematical <a href="/wiki/Finitism" title="Finitism">finitism</a>, and are used in several contexts in mathematical logic where a particularly constructive system is desired. <a href="/wiki/Primitive_recursive_arithmetic" title="Primitive recursive arithmetic">Primitive recursive arithmetic</a> (PRA), a formal axiom system for the natural numbers and the primitive recursive functions on them, is often used for this purpose.
</p><p>PRA is much weaker than <a href="/wiki/Peano_arithmetic" class="mw-redirect" title="Peano arithmetic">Peano arithmetic</a>, which is not a finitistic system. Nevertheless, many results in <a href="/wiki/Number_theory" title="Number theory">number theory</a> and in <a href="/wiki/Proof_theory" title="Proof theory">proof theory</a> can be proved in PRA. For example, <a href="/wiki/G%C3%B6del%27s_incompleteness_theorem" class="mw-redirect" title="Gödel&#39;s incompleteness theorem">Gödel's incompleteness theorem</a> can be formalized into PRA, giving the following theorem:
</p>
<dl><dd>If <i>T</i> is a theory of arithmetic satisfying certain hypotheses, with Gödel sentence <i>G</i><sub><i>T</i></sub>, then PRA proves the implication Con(<i>T</i>)&#8594;<i>G</i><sub><i>T</i></sub>.</dd></dl>
<p>Similarly, many of the syntactic results in proof theory can be proved in PRA, which implies that there are primitive recursive functions that carry out the corresponding syntactic transformations of proofs.
</p><p>In proof theory and <a href="/wiki/Set_theory" title="Set theory">set theory</a>, there is an interest in finitistic <a href="/wiki/Consistency_proof" class="mw-redirect" title="Consistency proof">consistency proofs</a>, that is, consistency proofs that themselves are finitistically acceptable. Such a proof establishes that the consistency of a theory <i>T</i> implies the consistency of a theory <i>S</i> by producing a primitive recursive function that can transform any proof of an inconsistency from <i>S</i> into a proof of an inconsistency from <i>T</i>.  One sufficient condition for a consistency proof to be finitistic is the ability to formalize it in PRA. For example, many consistency results in set theory that are obtained by <a href="/wiki/Forcing_(mathematics)" title="Forcing (mathematics)">forcing</a> can be recast as syntactic proofs that can be formalized in PRA.
</p>
<h2><span class="mw-headline" id="History">History</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Primitive_recursive_function&amp;action=edit&amp;section=16" title="Edit section: History">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<p><a href="/wiki/Recursive_definition" title="Recursive definition">Recursive definitions</a> had been used more or less formally in mathematics before, but the construction of primitive recursion is traced back to <a href="/wiki/Richard_Dedekind" title="Richard Dedekind">Richard Dedekind</a>'s theorem 126 of his <i>Was sind und was sollen die Zahlen?</i> (1888). This work was the first to give a proof that a certain recursive construction defines a unique function.<sup id="cite_ref-Smith2013_4-0" class="reference"><a href="#cite_note-Smith2013-4">&#91;4&#93;</a></sup><sup id="cite_ref-Tourlakis2003_5-0" class="reference"><a href="#cite_note-Tourlakis2003-5">&#91;5&#93;</a></sup><sup id="cite_ref-Downey2014_6-0" class="reference"><a href="#cite_note-Downey2014-6">&#91;6&#93;</a></sup>
</p><p><a href="/wiki/Primitive_recursive_arithmetic" title="Primitive recursive arithmetic">Primitive recursive arithmetic</a>  was first proposed by <a href="/wiki/Thoralf_Skolem" title="Thoralf Skolem">Thoralf Skolem</a><sup id="cite_ref-7" class="reference"><a href="#cite_note-7">&#91;7&#93;</a></sup> in 1923.
</p><p>The current terminology was coined by <a href="/wiki/R%C3%B3zsa_P%C3%A9ter" title="Rózsa Péter">Rózsa Péter</a> (1934) after <a href="/wiki/Wilhelm_Ackermann" title="Wilhelm Ackermann">Ackermann</a> had proved in 1928 that the function which today is named after him was not primitive recursive, an event which prompted the need to rename what until then were simply called recursive functions.<sup id="cite_ref-Tourlakis2003_5-1" class="reference"><a href="#cite_note-Tourlakis2003-5">&#91;5&#93;</a></sup><sup id="cite_ref-Downey2014_6-1" class="reference"><a href="#cite_note-Downey2014-6">&#91;6&#93;</a></sup>
</p>
<h2><span class="mw-headline" id="See_also">See also</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Primitive_recursive_function&amp;action=edit&amp;section=17" title="Edit section: See also">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ul><li><a href="/wiki/Grzegorczyk_hierarchy" title="Grzegorczyk hierarchy">Grzegorczyk hierarchy</a></li>
<li><a href="/wiki/Recursion_(computer_science)" title="Recursion (computer science)">Recursion (computer science)</a></li>
<li><a href="/wiki/Primitive_recursive_functional" title="Primitive recursive functional">Primitive recursive functional</a></li>
<li><a href="/wiki/Double_recursion" title="Double recursion">Double recursion</a></li>
<li><a href="/wiki/Primitive_recursive_set_function" title="Primitive recursive set function">Primitive recursive set function</a></li>
<li><a href="/wiki/Primitive_recursive_ordinal_function" class="mw-redirect" title="Primitive recursive ordinal function">Primitive recursive ordinal function</a></li></ul>
<h2><span class="mw-headline" id="Notes">Notes</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Primitive_recursive_function&amp;action=edit&amp;section=18" title="Edit section: Notes">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<div class="reflist" style="list-style-type: decimal;">
<div class="mw-references-wrap"><ol class="references">
<li id="cite_note-1"><span class="mw-cite-backlink"><b><a href="#cite_ref-1">^</a></b></span> <span class="reference-text">Brainerd and Landweber, 1974</span>
</li>
<li id="cite_note-2"><span class="mw-cite-backlink"><b><a href="#cite_ref-2">^</a></b></span> <span class="reference-text">Kleene [1952 pp.&#160;226–227]</span>
</li>
<li id="cite_note-3"><span class="mw-cite-backlink"><b><a href="#cite_ref-3">^</a></b></span> <span class="reference-text">This follows from the facts that the functions of this form are the most quickly growing primitive recursive functions, and that a function is primitive recursive if and only if its time complexity is bounded by a primitive recursive function. For the former, see <cite id="CITEREFLinz2011" class="citation">Linz, Peter (2011), <a rel="nofollow" class="external text" href="https://books.google.com/books?id=hsxDiWvVdBcC&amp;pg=PA332"><i>An Introduction to Formal Languages and Automata</i></a>, Jones &amp; Bartlett Publishers, p.&#160;332, <a href="/wiki/International_Standard_Book_Number" title="International Standard Book Number">ISBN</a>&#160;<a href="/wiki/Special:BookSources/9781449615529" title="Special:BookSources/9781449615529"><bdi>9781449615529</bdi></a></cite><span title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=book&amp;rft.btitle=An+Introduction+to+Formal+Languages+and+Automata&amp;rft.pages=332&amp;rft.pub=Jones+%26+Bartlett+Publishers&amp;rft.date=2011&amp;rft.isbn=9781449615529&amp;rft.aulast=Linz&amp;rft.aufirst=Peter&amp;rft_id=https%3A%2F%2Fbooks.google.com%2Fbooks%3Fid%3DhsxDiWvVdBcC%26pg%3DPA332&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3APrimitive+recursive+function" class="Z3988"></span><style data-mw-deduplicate="TemplateStyles:r935243608">.mw-parser-output cite.citation{font-style:inherit}.mw-parser-output .citation q{quotes:"\"""\"""'""'"}.mw-parser-output .id-lock-free a,.mw-parser-output .citation .cs1-lock-free a{background:url("//upload.wikimedia.org/wikipedia/commons/thumb/6/65/Lock-green.svg/9px-Lock-green.svg.png")no-repeat;background-position:right .1em center}.mw-parser-output .id-lock-limited a,.mw-parser-output .id-lock-registration a,.mw-parser-output .citation .cs1-lock-limited a,.mw-parser-output .citation .cs1-lock-registration a{background:url("//upload.wikimedia.org/wikipedia/commons/thumb/d/d6/Lock-gray-alt-2.svg/9px-Lock-gray-alt-2.svg.png")no-repeat;background-position:right .1em center}.mw-parser-output .id-lock-subscription a,.mw-parser-output .citation .cs1-lock-subscription a{background:url("//upload.wikimedia.org/wikipedia/commons/thumb/a/aa/Lock-red-alt-2.svg/9px-Lock-red-alt-2.svg.png")no-repeat;background-position:right .1em center}.mw-parser-output .cs1-subscription,.mw-parser-output .cs1-registration{color:#555}.mw-parser-output .cs1-subscription span,.mw-parser-output .cs1-registration span{border-bottom:1px dotted;cursor:help}.mw-parser-output .cs1-ws-icon a{background:url("//upload.wikimedia.org/wikipedia/commons/thumb/4/4c/Wikisource-logo.svg/12px-Wikisource-logo.svg.png")no-repeat;background-position:right .1em center}.mw-parser-output code.cs1-code{color:inherit;background:inherit;border:inherit;padding:inherit}.mw-parser-output .cs1-hidden-error{display:none;font-size:100%}.mw-parser-output .cs1-visible-error{font-size:100%}.mw-parser-output .cs1-maint{display:none;color:#33aa33;margin-left:0.3em}.mw-parser-output .cs1-subscription,.mw-parser-output .cs1-registration,.mw-parser-output .cs1-format{font-size:95%}.mw-parser-output .cs1-kern-left,.mw-parser-output .cs1-kern-wl-left{padding-left:0.2em}.mw-parser-output .cs1-kern-right,.mw-parser-output .cs1-kern-wl-right{padding-right:0.2em}</style>. For the latter, see <cite id="CITEREFMooreMertens2011" class="citation"><a href="/wiki/Cristopher_Moore" title="Cristopher Moore">Moore, Cristopher</a>; Mertens, Stephan (2011), <a rel="nofollow" class="external text" href="https://books.google.com/books?id=jnGKbpMV8xoC&amp;pg=PA287"><i>The Nature of Computation</i></a>, Oxford University Press, p.&#160;287, <a href="/wiki/International_Standard_Book_Number" title="International Standard Book Number">ISBN</a>&#160;<a href="/wiki/Special:BookSources/9780191620805" title="Special:BookSources/9780191620805"><bdi>9780191620805</bdi></a></cite><span title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=book&amp;rft.btitle=The+Nature+of+Computation&amp;rft.pages=287&amp;rft.pub=Oxford+University+Press&amp;rft.date=2011&amp;rft.isbn=9780191620805&amp;rft.aulast=Moore&amp;rft.aufirst=Cristopher&amp;rft.au=Mertens%2C+Stephan&amp;rft_id=https%3A%2F%2Fbooks.google.com%2Fbooks%3Fid%3DjnGKbpMV8xoC%26pg%3DPA287&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3APrimitive+recursive+function" class="Z3988"></span><link rel="mw-deduplicated-inline-style" href="mw-data:TemplateStyles:r935243608"/></span>
</li>
<li id="cite_note-Smith2013-4"><span class="mw-cite-backlink"><b><a href="#cite_ref-Smith2013_4-0">^</a></b></span> <span class="reference-text"><cite class="citation book">Peter Smith (2013). <i>An Introduction to Gödel's Theorems</i> (2nd ed.). Cambridge University Press. pp.&#160;98–99. <a href="/wiki/International_Standard_Book_Number" title="International Standard Book Number">ISBN</a>&#160;<a href="/wiki/Special:BookSources/978-1-107-02284-3" title="Special:BookSources/978-1-107-02284-3"><bdi>978-1-107-02284-3</bdi></a>.</cite><span title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=book&amp;rft.btitle=An+Introduction+to+G%C3%B6del%27s+Theorems&amp;rft.pages=98-99&amp;rft.edition=2nd&amp;rft.pub=Cambridge+University+Press&amp;rft.date=2013&amp;rft.isbn=978-1-107-02284-3&amp;rft.au=Peter+Smith&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3APrimitive+recursive+function" class="Z3988"></span><link rel="mw-deduplicated-inline-style" href="mw-data:TemplateStyles:r935243608"/></span>
</li>
<li id="cite_note-Tourlakis2003-5"><span class="mw-cite-backlink">^ <a href="#cite_ref-Tourlakis2003_5-0"><sup><i><b>a</b></i></sup></a> <a href="#cite_ref-Tourlakis2003_5-1"><sup><i><b>b</b></i></sup></a></span> <span class="reference-text"><cite class="citation book">George Tourlakis (2003). <i>Lectures in Logic and Set Theory: Volume 1, Mathematical Logic</i>. Cambridge University Press. p.&#160;129. <a href="/wiki/International_Standard_Book_Number" title="International Standard Book Number">ISBN</a>&#160;<a href="/wiki/Special:BookSources/978-1-139-43942-8" title="Special:BookSources/978-1-139-43942-8"><bdi>978-1-139-43942-8</bdi></a>.</cite><span title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=book&amp;rft.btitle=Lectures+in+Logic+and+Set+Theory%3A+Volume+1%2C+Mathematical+Logic&amp;rft.pages=129&amp;rft.pub=Cambridge+University+Press&amp;rft.date=2003&amp;rft.isbn=978-1-139-43942-8&amp;rft.au=George+Tourlakis&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3APrimitive+recursive+function" class="Z3988"></span><link rel="mw-deduplicated-inline-style" href="mw-data:TemplateStyles:r935243608"/></span>
</li>
<li id="cite_note-Downey2014-6"><span class="mw-cite-backlink">^ <a href="#cite_ref-Downey2014_6-0"><sup><i><b>a</b></i></sup></a> <a href="#cite_ref-Downey2014_6-1"><sup><i><b>b</b></i></sup></a></span> <span class="reference-text"><cite class="citation book">Rod Downey, ed. (2014). <i>Turing's Legacy: Developments from Turing's Ideas in Logic</i>. Cambridge University Press. p.&#160;474. <a href="/wiki/International_Standard_Book_Number" title="International Standard Book Number">ISBN</a>&#160;<a href="/wiki/Special:BookSources/978-1-107-04348-0" title="Special:BookSources/978-1-107-04348-0"><bdi>978-1-107-04348-0</bdi></a>.</cite><span title="ctx_ver=Z39.88-2004&amp;rft_val_fmt=info%3Aofi%2Ffmt%3Akev%3Amtx%3Abook&amp;rft.genre=book&amp;rft.btitle=Turing%27s+Legacy%3A+Developments+from+Turing%27s+Ideas+in+Logic&amp;rft.pages=474&amp;rft.pub=Cambridge+University+Press&amp;rft.date=2014&amp;rft.isbn=978-1-107-04348-0&amp;rfr_id=info%3Asid%2Fen.wikipedia.org%3APrimitive+recursive+function" class="Z3988"></span><link rel="mw-deduplicated-inline-style" href="mw-data:TemplateStyles:r935243608"/></span>
</li>
<li id="cite_note-7"><span class="mw-cite-backlink"><b><a href="#cite_ref-7">^</a></b></span> <span class="reference-text"><a href="/wiki/Thoralf_Skolem" title="Thoralf Skolem">Thoralf Skolem</a> (1923) "The foundations of elementary arithmetic" in <a href="/wiki/Jean_van_Heijenoort" title="Jean van Heijenoort">Jean van Heijenoort</a>, translator and ed. (1967) <i>From Frege to Gödel: A Source Book in Mathematical Logic, 1879-1931</i>. Harvard Univ. Press: 302-33.</span>
</li>
</ol></div></div>
<h2><span class="mw-headline" id="References">References</span><span class="mw-editsection"><span class="mw-editsection-bracket">[</span><a href="/w/index.php?title=Primitive_recursive_function&amp;action=edit&amp;section=19" title="Edit section: References">edit</a><span class="mw-editsection-bracket">]</span></span></h2>
<ul><li>Brainerd, W.S., Landweber, L.H. (1974), <i>Theory of Computation</i>, Wiley, <link rel="mw-deduplicated-inline-style" href="mw-data:TemplateStyles:r935243608"/><a href="/wiki/International_Standard_Book_Number" title="International Standard Book Number">ISBN</a>&#160;<a href="/wiki/Special:BookSources/0-471-09585-0" title="Special:BookSources/0-471-09585-0">0-471-09585-0</a></li>
<li><a href="/wiki/Robert_I._Soare" title="Robert I. Soare">Robert I. Soare</a>, <i>Recursively Enumerable Sets and Degrees</i>, Springer-Verlag, 1987.  <link rel="mw-deduplicated-inline-style" href="mw-data:TemplateStyles:r935243608"/><a href="/wiki/International_Standard_Book_Number" title="International Standard Book Number">ISBN</a>&#160;<a href="/wiki/Special:BookSources/0-387-15299-7" title="Special:BookSources/0-387-15299-7">0-387-15299-7</a></li>
<li><a href="/wiki/Stephen_Kleene" class="mw-redirect" title="Stephen Kleene">Stephen Kleene</a> (1952) <i>Introduction to Metamathematics</i>, North-Holland Publishing Company, New York, 11th reprint 1971: (2nd edition notes added on 6th reprint). In Chapter XI. General Recursive Functions §57</li>
<li><a href="/wiki/George_Boolos" title="George Boolos">George Boolos</a>, <a href="/wiki/John_P._Burgess" title="John P. Burgess">John Burgess</a>, <a href="/wiki/Richard_Jeffrey" title="Richard Jeffrey">Richard Jeffrey</a> (2002), <i>Computability and Logic: Fourth Edition</i>, Cambridge University Press, Cambridge, UK. Cf pp.&#160;70–71.</li>
<li>Robert I. Soare 1995 <i>Computability and Recursion</i> <a rel="nofollow" class="external free" href="http://www.people.cs.uchicago.edu/~soare/History/compute.pdf">http://www.people.cs.uchicago.edu/~soare/History/compute.pdf</a></li>
<li>Daniel Severin 2008, <i>Unary primitive recursive functions</i>, J. Symbolic Logic Volume 73, Issue 4, pp.&#160;1122–1138 <a rel="nofollow" class="external text" href="https://arxiv.org/abs/cs/0603063v3">arXiv</a> <a rel="nofollow" class="external text" href="http://projecteuclid.org/DPubS?service=UI&amp;version=1.0&amp;verb=Display&amp;handle=euclid.jsl/1230396909">projecteuclid</a></li></ul>
<div role="navigation" class="navbox" aria-labelledby="Mathematical_logic" style="padding:3px"><table class="nowraplinks mw-collapsible autocollapse navbox-inner" style="border-spacing:0;background:transparent;color:inherit"><tbody><tr><th scope="col" class="navbox-title" colspan="2"><div class="plainlinks hlist navbar mini"><ul><li class="nv-view"><a href="/wiki/Template:Mathematical_logic" title="Template:Mathematical logic"><abbr title="View this template" style=";;background:none transparent;border:none;-moz-box-shadow:none;-webkit-box-shadow:none;box-shadow:none; padding:0;">v</abbr></a></li><li class="nv-talk"><a href="/wiki/Template_talk:Mathematical_logic" title="Template talk:Mathematical logic"><abbr title="Discuss this template" style=";;background:none transparent;border:none;-moz-box-shadow:none;-webkit-box-shadow:none;box-shadow:none; padding:0;">t</abbr></a></li><li class="nv-edit"><a class="external text" href="https://en.wikipedia.org/w/index.php?title=Template:Mathematical_logic&amp;action=edit"><abbr title="Edit this template" style=";;background:none transparent;border:none;-moz-box-shadow:none;-webkit-box-shadow:none;box-shadow:none; padding:0;">e</abbr></a></li></ul></div><div id="Mathematical_logic" style="font-size:114%;margin:0 4em"><a href="/wiki/Mathematical_logic" title="Mathematical logic">Mathematical logic</a></div></th></tr><tr><th scope="row" class="navbox-group" style="width:1%">General</th><td class="navbox-list navbox-odd hlist" style="text-align:left;border-left-width:2px;border-left-style:solid;width:100%;padding:0px"><div style="padding:0em 0.25em">
<ul><li><a href="/wiki/Formal_language" title="Formal language">Formal language</a></li>
<li><a href="/wiki/Formation_rule" title="Formation rule">Formation rule</a></li>
<li><a href="/wiki/Formal_proof" title="Formal proof">Formal proof</a></li>
<li><a href="/wiki/Formal_semantics_(logic)" class="mw-redirect" title="Formal semantics (logic)">Formal semantics</a></li>
<li><a href="/wiki/Well-formed_formula" title="Well-formed formula">Well-formed formula</a></li>
<li><a href="/wiki/Set_(mathematics)" title="Set (mathematics)">Set</a></li>
<li><a href="/wiki/Element_(mathematics)" title="Element (mathematics)">Element</a></li>
<li><a href="/wiki/Class_(set_theory)" title="Class (set theory)">Class</a></li>
<li><a href="/wiki/Classical_logic" title="Classical logic">Classical logic</a></li>
<li><a href="/wiki/Axiom" title="Axiom">Axiom</a></li>
<li><a href="/wiki/Rule_of_inference" title="Rule of inference">Rule of inference</a></li>
<li><a href="/wiki/Finitary_relation" title="Finitary relation">Relation</a></li>
<li><a href="/wiki/Theorem" title="Theorem">Theorem</a></li>
<li><a href="/wiki/Logical_consequence" title="Logical consequence">Logical consequence</a></li>
<li><a href="/wiki/Type_theory" title="Type theory">Type theory</a></li>
<li><a href="/wiki/Symbol_(formal)" title="Symbol (formal)">Symbol</a></li>
<li><a href="/wiki/Syntax_(logic)" title="Syntax (logic)">Syntax</a></li>
<li><a href="/wiki/Theory_(mathematical_logic)" title="Theory (mathematical logic)">Theory</a></li></ul>
</div></td></tr><tr><th scope="row" class="navbox-group" style="width:1%">Systems</th><td class="navbox-list navbox-even hlist" style="text-align:left;border-left-width:2px;border-left-style:solid;width:100%;padding:0px"><div style="padding:0em 0.25em">
<ul><li><a href="/wiki/Formal_system" title="Formal system">Formal system</a></li>
<li><a href="/wiki/Deductive_system" class="mw-redirect" title="Deductive system">Deductive system</a></li>
<li><a href="/wiki/Axiomatic_system" title="Axiomatic system">Axiomatic system</a></li>
<li><a href="/wiki/Hilbert_system" title="Hilbert system">Hilbert style systems</a></li>
<li><a href="/wiki/Natural_deduction" title="Natural deduction">Natural deduction</a></li>
<li><a href="/wiki/Sequent_calculus" title="Sequent calculus">Sequent calculus</a></li></ul>
</div></td></tr><tr><th scope="row" class="navbox-group" style="width:1%"><a href="/wiki/Term_logic" title="Term logic">Traditional logic</a></th><td class="navbox-list navbox-odd hlist" style="text-align:left;border-left-width:2px;border-left-style:solid;width:100%;padding:0px"><div style="padding:0em 0.25em">
<ul><li><a href="/wiki/Proposition" title="Proposition">Proposition</a></li>
<li><a href="/wiki/Inference" title="Inference">Inference</a></li>
<li><a href="/wiki/Argument" title="Argument">Argument</a></li>
<li><a href="/wiki/Validity_(logic)" title="Validity (logic)">Validity</a></li>
<li><a href="/w/index.php?title=Cogency&amp;action=edit&amp;redlink=1" class="new" title="Cogency (page does not exist)">Cogency</a></li>
<li><a href="/wiki/Syllogism" title="Syllogism">Syllogism</a></li>
<li><a href="/wiki/Square_of_opposition" title="Square of opposition">Square of opposition</a></li>
<li><a href="/wiki/Venn_diagram" title="Venn diagram">Venn diagram</a></li></ul>
</div></td></tr><tr><th scope="row" class="navbox-group" style="width:1%"><div style="padding:0.1em 0;line-height:1.2em;"><a href="/wiki/Propositional_calculus" title="Propositional calculus">Propositional calculus</a><br />and <a href="/wiki/Boolean_algebra" title="Boolean algebra">Boolean logic</a></div></th><td class="navbox-list navbox-even hlist" style="text-align:left;border-left-width:2px;border-left-style:solid;width:100%;padding:0px"><div style="padding:0em 0.25em">
<ul><li><a href="/wiki/Boolean_function" title="Boolean function">Boolean functions</a></li>
<li><a href="/wiki/Propositional_calculus" title="Propositional calculus">Propositional calculus</a></li>
<li><a href="/wiki/Propositional_formula" title="Propositional formula">Propositional formula</a></li>
<li><a href="/wiki/Logical_connective" title="Logical connective">Logical connectives</a></li>
<li><a href="/wiki/Truth_table" title="Truth table">Truth tables</a></li>
<li><a href="/wiki/Many-valued_logic" title="Many-valued logic">Many-valued logic</a></li></ul>
</div></td></tr><tr><th scope="row" class="navbox-group" style="width:1%"><a href="/wiki/Predicate_logic" class="mw-redirect" title="Predicate logic">Predicate logic</a></th><td class="navbox-list navbox-odd hlist" style="text-align:left;border-left-width:2px;border-left-style:solid;width:100%;padding:0px"><div style="padding:0em 0.25em">
<ul><li><a href="/wiki/First-order_logic" title="First-order logic">First-order</a></li>
<li><a href="/wiki/Quantifier_(logic)" title="Quantifier (logic)">Quantifiers</a></li>
<li><a href="/wiki/Predicate_(mathematical_logic)" title="Predicate (mathematical logic)">Predicate</a></li>
<li><a href="/wiki/Second-order_logic" title="Second-order logic">Second-order</a></li>
<li><a href="/wiki/Monadic_predicate_calculus" title="Monadic predicate calculus">Monadic predicate calculus</a></li></ul>
</div></td></tr><tr><th scope="row" class="navbox-group" style="width:1%"><a href="/wiki/Naive_set_theory" title="Naive set theory">Naive set theory</a></th><td class="navbox-list navbox-even hlist" style="text-align:left;border-left-width:2px;border-left-style:solid;width:100%;padding:0px"><div style="padding:0em 0.25em">
<ul><li><a href="/wiki/Set_(mathematics)" title="Set (mathematics)">Set</a></li>
<li><a href="/wiki/Empty_set" title="Empty set">Empty set</a></li>
<li><a href="/wiki/Element_(mathematics)" title="Element (mathematics)">Element</a></li>
<li><a href="/wiki/Enumeration" title="Enumeration">Enumeration</a></li>
<li><a href="/wiki/Extensionality" title="Extensionality">Extensionality</a></li>
<li><a href="/wiki/Finite_set" title="Finite set">Finite set</a></li>
<li><a href="/wiki/Infinite_set" title="Infinite set">Infinite set</a></li>
<li><a href="/wiki/Subset" title="Subset">Subset</a></li>
<li><a href="/wiki/Power_set" title="Power set">Power set</a></li>
<li><a href="/wiki/Countable_set" title="Countable set">Countable set</a></li>
<li><a href="/wiki/Uncountable_set" title="Uncountable set">Uncountable set</a></li>
<li><a href="/wiki/Recursive_set" title="Recursive set">Recursive set</a></li>
<li><a href="/wiki/Domain_of_a_function" title="Domain of a function">Domain</a></li>
<li><a href="/wiki/Codomain" title="Codomain">Codomain</a></li>
<li><a href="/wiki/Image_(mathematics)" title="Image (mathematics)">Image</a></li>
<li><a href="/wiki/Map_(mathematics)" title="Map (mathematics)">Map</a></li>
<li><a href="/wiki/Function_(mathematics)" title="Function (mathematics)">Function</a></li>
<li><a href="/wiki/Binary_operation" title="Binary operation">Relation</a></li>
<li><a href="/wiki/Ordered_pair" title="Ordered pair">Ordered pair</a></li></ul>
</div></td></tr><tr><th scope="row" class="navbox-group" style="width:1%"><a href="/wiki/Set_theory" title="Set theory">Set theory</a></th><td class="navbox-list navbox-odd hlist" style="text-align:left;border-left-width:2px;border-left-style:solid;width:100%;padding:0px"><div style="padding:0em 0.25em">
<ul><li><a href="/wiki/Foundations_of_mathematics" title="Foundations of mathematics">Foundations of mathematics</a></li>
<li><a href="/wiki/Zermelo%E2%80%93Fraenkel_set_theory" title="Zermelo–Fraenkel set theory">Zermelo–Fraenkel set theory</a></li>
<li><a href="/wiki/Axiom_of_choice" title="Axiom of choice">Axiom of choice</a></li>
<li><a href="/wiki/General_set_theory" title="General set theory">General set theory</a></li>
<li><a href="/wiki/Kripke%E2%80%93Platek_set_theory" title="Kripke–Platek set theory">Kripke–Platek set theory</a></li>
<li><a href="/wiki/Von_Neumann%E2%80%93Bernays%E2%80%93G%C3%B6del_set_theory" title="Von Neumann–Bernays–Gödel set theory">Von Neumann–Bernays–Gödel set theory</a></li>
<li><a href="/wiki/Morse%E2%80%93Kelley_set_theory" title="Morse–Kelley set theory">Morse–Kelley set theory</a></li>
<li><a href="/wiki/Tarski%E2%80%93Grothendieck_set_theory" title="Tarski–Grothendieck set theory">Tarski–Grothendieck set theory</a></li></ul>
</div></td></tr><tr><th scope="row" class="navbox-group" style="width:1%"><a href="/wiki/Model_theory" title="Model theory">Model theory</a></th><td class="navbox-list navbox-even hlist" style="text-align:left;border-left-width:2px;border-left-style:solid;width:100%;padding:0px"><div style="padding:0em 0.25em">
<ul><li><a href="/wiki/Structure_(mathematical_logic)" title="Structure (mathematical logic)">Model</a></li>
<li><a href="/wiki/Interpretation_(logic)" title="Interpretation (logic)">Interpretation</a></li>
<li><a href="/wiki/Non-standard_model" title="Non-standard model">Non-standard model</a></li>
<li><a href="/wiki/Finite_model_theory" title="Finite model theory">Finite model theory</a></li>
<li><a href="/wiki/Truth_value" title="Truth value">Truth value</a></li>
<li><a href="/wiki/Validity_(logic)" title="Validity (logic)">Validity</a></li></ul>
</div></td></tr><tr><th scope="row" class="navbox-group" style="width:1%"><a href="/wiki/Proof_theory" title="Proof theory">Proof theory</a></th><td class="navbox-list navbox-odd hlist" style="text-align:left;border-left-width:2px;border-left-style:solid;width:100%;padding:0px"><div style="padding:0em 0.25em">
<ul><li><a href="/wiki/Formal_proof" title="Formal proof">Formal proof</a></li>
<li><a href="/wiki/Deductive_system" class="mw-redirect" title="Deductive system">Deductive system</a></li>
<li><a href="/wiki/Formal_system" title="Formal system">Formal system</a></li>
<li><a href="/wiki/Theorem" title="Theorem">Theorem</a></li>
<li><a href="/wiki/Logical_consequence" title="Logical consequence">Logical consequence</a></li>
<li><a href="/wiki/Rule_of_inference" title="Rule of inference">Rule of inference</a></li>
<li><a href="/wiki/Syntax_(logic)" title="Syntax (logic)">Syntax</a></li></ul>
</div></td></tr><tr><th scope="row" class="navbox-group" style="width:1%"><a href="/wiki/Computability_theory" title="Computability theory">Computability <br />theory</a></th><td class="navbox-list navbox-even hlist" style="text-align:left;border-left-width:2px;border-left-style:solid;width:100%;padding:0px"><div style="padding:0em 0.25em">
<ul><li><a href="/wiki/Recursion" title="Recursion">Recursion</a></li>
<li><a href="/wiki/Recursive_set" title="Recursive set">Recursive set</a></li>
<li><a href="/wiki/Recursively_enumerable_set" title="Recursively enumerable set">Recursively enumerable set</a></li>
<li><a href="/wiki/Decision_problem" title="Decision problem">Decision problem</a></li>
<li><a href="/wiki/Church%E2%80%93Turing_thesis" title="Church–Turing thesis">Church–Turing thesis</a></li>
<li><a href="/wiki/Computable_function" title="Computable function">Computable function</a></li>
<li><a class="mw-selflink selflink">Primitive recursive function</a></li></ul>
</div></td></tr></tbody></table></div>
<!-- 
NewPP limit report
Parsed by mw1323
Cached time: 20200401065617
Cache expiry: 2592000
Dynamic content: false
Complications: [vary‐revision‐sha1]
CPU time usage: 0.264 seconds
Real time usage: 0.382 seconds
Preprocessor visited node count: 1257/1000000
Post‐expand include size: 37064/2097152 bytes
Template argument size: 4631/2097152 bytes
Highest expansion depth: 13/40
Expensive parser function count: 0/500
Unstrip recursion depth: 1/20
Unstrip post‐expand size: 21564/5000000 bytes
Number of Wikibase entities loaded: 0/400
Lua time usage: 0.104/10.000 seconds
Lua memory usage: 2.82 MB/50 MB
-->
<!--
Transclusion expansion time report (%,ms,calls,template)
100.00%  266.106      1 -total
 49.77%  132.429      1 Template:Reflist
 33.68%   89.628      2 Template:Citation
 21.61%   57.510      2 Template:Isbn
  9.93%   26.412      3 Template:Ordered_list
  8.19%   21.793      3 Template:Cite_book
  7.38%   19.643      2 Template:Catalog_lookup_link
  7.21%   19.175      1 Template:Mathematical_logic
  5.80%   15.423      1 Template:Navbox
  4.98%   13.239      1 Template:Block_indent
-->

<!-- Saved in parser cache with key enwiki:pcache:idhash:24829-0!canonical!math=5 and timestamp 20200401065617 and revision id 946623663
 -->
</div><noscript><img src="//en.wikipedia.org/wiki/Special:CentralAutoLogin/start?type=1x1" alt="" title="" width="1" height="1" style="border: none; position: absolute;" /></noscript></div>
		<div class="printfooter">Retrieved from "<a dir="ltr" href="https://en.wikipedia.org/w/index.php?title=Primitive_recursive_function&amp;oldid=946623663">https://en.wikipedia.org/w/index.php?title=Primitive_recursive_function&amp;oldid=946623663</a>"</div>
		<div id="catlinks" class="catlinks" data-mw="interface"><div id="mw-normal-catlinks" class="mw-normal-catlinks"><a href="/wiki/Help:Category" title="Help:Category">Categories</a>: <ul><li><a href="/wiki/Category:Computability_theory" title="Category:Computability theory">Computability theory</a></li><li><a href="/wiki/Category:Theory_of_computation" title="Category:Theory of computation">Theory of computation</a></li><li><a href="/wiki/Category:Functions_and_mappings" title="Category:Functions and mappings">Functions and mappings</a></li><li><a href="/wiki/Category:Recursion" title="Category:Recursion">Recursion</a></li></ul></div></div>
		<div class="visualClear"></div>
		
	</div>
</div>
<div id='mw-data-after-content'>
	<div class="read-more-container"></div>
</div>

<div id="mw-navigation">
    <h2>Navigation menu</h2>
    <div id="mw-head">
        
        <div id="p-personal" role="navigation" class="" aria-labelledby="p-personal-label">
        	<h3 id="p-personal-label">Personal tools</h3>
        	<ul >
        		
        		<li id="pt-anonuserpage">Not logged in</li>
        		<li id="pt-anontalk"><a href="/wiki/Special:MyTalk" title="Discussion about edits from this IP address [n]" accesskey="n">Talk</a></li><li id="pt-anoncontribs"><a href="/wiki/Special:MyContributions" title="A list of edits made from this IP address [y]" accesskey="y">Contributions</a></li><li id="pt-createaccount"><a href="/w/index.php?title=Special:CreateAccount&amp;returnto=Primitive+recursive+function" title="You are encouraged to create an account and log in; however, it is not mandatory">Create account</a></li><li id="pt-login"><a href="/w/index.php?title=Special:UserLogin&amp;returnto=Primitive+recursive+function" title="You&#039;re encouraged to log in; however, it&#039;s not mandatory. [o]" accesskey="o">Log in</a></li>
        	</ul>
        </div>
        <div id="left-navigation">
            <div id="p-namespaces" role="navigation" class="vectorTabs " aria-labelledby="p-namespaces-label">
            	<h3 id="p-namespaces-label">Namespaces</h3>
            	<ul >
            		<li id="ca-nstab-main" class="selected"><a href="/wiki/Primitive_recursive_function" title="View the content page [c]" accesskey="c">Article</a></li><li id="ca-talk"><a href="/wiki/Talk:Primitive_recursive_function" rel="discussion" title="Discuss improvements to the content page [t]" accesskey="t">Talk</a></li>
            	</ul>
            </div>
            <div id="p-variants" role="navigation" class="vectorMenu emptyPortlet" aria-labelledby="p-variants-label">
            	<input type="checkbox" class="vectorMenuCheckbox" aria-labelledby="p-variants-label" />
            	<h3 id="p-variants-label">
            		<span>Variants</span>
            	</h3>
            	<ul class="menu" >
            		
            	</ul>
            </div>
        </div>
        <div id="right-navigation">
            <div id="p-views" role="navigation" class="vectorTabs " aria-labelledby="p-views-label">
            	<h3 id="p-views-label">Views</h3>
            	<ul >
            		<li id="ca-view" class="collapsible selected"><a href="/wiki/Primitive_recursive_function">Read</a></li><li id="ca-edit" class="collapsible"><a href="/w/index.php?title=Primitive_recursive_function&amp;action=edit" title="Edit this page [e]" accesskey="e">Edit</a></li><li id="ca-history" class="collapsible"><a href="/w/index.php?title=Primitive_recursive_function&amp;action=history" title="Past revisions of this page [h]" accesskey="h">View history</a></li>
            	</ul>
            </div>
            <div id="p-cactions" role="navigation" class="vectorMenu emptyPortlet" aria-labelledby="p-cactions-label">
            	<input type="checkbox" class="vectorMenuCheckbox" aria-labelledby="p-cactions-label" />
            	<h3 id="p-cactions-label">
            		<span>More</span>
            	</h3>
            	<ul class="menu" >
            		
            	</ul>
            </div>
            <div id="p-search" role="search">
            	<h3 >
            		<label for="searchInput">Search</label>
            	</h3>
            	<form action="/w/index.php" id="searchform">
            		<div id="simpleSearch">
            			<input type="search" name="search" placeholder="Search Wikipedia" title="Search Wikipedia [f]" accesskey="f" id="searchInput"/>
            			<input type="hidden" value="Special:Search" name="title"/>
            			<input type="submit" name="fulltext" value="Search" title="Search Wikipedia for this text" id="mw-searchButton" class="searchButton mw-fallbackSearchButton"/>
            			<input type="submit" name="go" value="Go" title="Go to a page with this exact name if it exists" id="searchButton" class="searchButton"/>
            		</div>
            	</form>
            </div>
        </div>
    </div>
    
    <div id="mw-panel">
    	<div id="p-logo" role="banner">
    		<a  title="Visit the main page" class="mw-wiki-logo" href="/wiki/Main_Page"></a>
    	</div>
    	<div class="portal" role="navigation" id="p-navigation"  aria-labelledby="p-navigation-label">
    		<h3  id="p-navigation-label">
    			Navigation
    		</h3>
    		<div class="body">
    			<ul><li id="n-mainpage-description"><a href="/wiki/Main_Page" title="Visit the main page [z]" accesskey="z">Main page</a></li><li id="n-contents"><a href="/wiki/Wikipedia:Contents" title="Guides to browsing Wikipedia">Contents</a></li><li id="n-featuredcontent"><a href="/wiki/Wikipedia:Featured_content" title="Featured content – the best of Wikipedia">Featured content</a></li><li id="n-currentevents"><a href="/wiki/Portal:Current_events" title="Find background information on current events">Current events</a></li><li id="n-randompage"><a href="/wiki/Special:Random" title="Load a random article [x]" accesskey="x">Random article</a></li><li id="n-sitesupport"><a href="https://donate.wikimedia.org/wiki/Special:FundraiserRedirector?utm_source=donate&amp;utm_medium=sidebar&amp;utm_campaign=C13_en.wikipedia.org&amp;uselang=en" title="Support us">Donate to Wikipedia</a></li><li id="n-shoplink"><a href="//shop.wikimedia.org" title="Visit the Wikipedia store">Wikipedia store</a></li></ul>
    			
    		</div>
    	</div>
    	
    	<div class="portal" role="navigation" id="p-interaction"  aria-labelledby="p-interaction-label">
    		<h3  id="p-interaction-label">
    			Interaction
    		</h3>
    		<div class="body">
    			<ul><li id="n-help"><a href="/wiki/Help:Contents" title="Guidance on how to use and edit Wikipedia">Help</a></li><li id="n-aboutsite"><a href="/wiki/Wikipedia:About" title="Find out about Wikipedia">About Wikipedia</a></li><li id="n-portal"><a href="/wiki/Wikipedia:Community_portal" title="About the project, what you can do, where to find things">Community portal</a></li><li id="n-recentchanges"><a href="/wiki/Special:RecentChanges" title="A list of recent changes in the wiki [r]" accesskey="r">Recent changes</a></li><li id="n-contactpage"><a href="//en.wikipedia.org/wiki/Wikipedia:Contact_us" title="How to contact Wikipedia">Contact page</a></li></ul>
    			
    		</div>
    	</div>
    	
    	<div class="portal" role="navigation" id="p-tb"  aria-labelledby="p-tb-label">
    		<h3  id="p-tb-label">
    			Tools
    		</h3>
    		<div class="body">
    			<ul><li id="t-whatlinkshere"><a href="/wiki/Special:WhatLinksHere/Primitive_recursive_function" title="List of all English Wikipedia pages containing links to this page [j]" accesskey="j">What links here</a></li><li id="t-recentchangeslinked"><a href="/wiki/Special:RecentChangesLinked/Primitive_recursive_function" rel="nofollow" title="Recent changes in pages linked from this page [k]" accesskey="k">Related changes</a></li><li id="t-upload"><a href="/wiki/Wikipedia:File_Upload_Wizard" title="Upload files [u]" accesskey="u">Upload file</a></li><li id="t-specialpages"><a href="/wiki/Special:SpecialPages" title="A list of all special pages [q]" accesskey="q">Special pages</a></li><li id="t-permalink"><a href="/w/index.php?title=Primitive_recursive_function&amp;oldid=946623663" title="Permanent link to this revision of the page">Permanent link</a></li><li id="t-info"><a href="/w/index.php?title=Primitive_recursive_function&amp;action=info" title="More information about this page">Page information</a></li><li id="t-wikibase"><a href="https://www.wikidata.org/wiki/Special:EntityPage/Q1570472" title="Link to connected data repository item [g]" accesskey="g">Wikidata item</a></li><li id="t-cite"><a href="/w/index.php?title=Special:CiteThisPage&amp;page=Primitive_recursive_function&amp;id=946623663&amp;wpFormIdentifier=titleform" title="Information on how to cite this page">Cite this page</a></li></ul>
    			
    		</div>
    	</div>
    	
    	<div class="portal" role="navigation" id="p-coll-print_export"  aria-labelledby="p-coll-print_export-label">
    		<h3  id="p-coll-print_export-label">
    			Print/export
    		</h3>
    		<div class="body">
    			<ul><li id="coll-create_a_book"><a href="/w/index.php?title=Special:Book&amp;bookcmd=book_creator&amp;referer=Primitive+recursive+function">Create a book</a></li><li id="coll-download-as-rl"><a href="/w/index.php?title=Special:ElectronPdf&amp;page=Primitive+recursive+function&amp;action=show-download-screen">Download as PDF</a></li><li id="t-print"><a href="/w/index.php?title=Primitive_recursive_function&amp;printable=yes" title="Printable version of this page [p]" accesskey="p">Printable version</a></li></ul>
    			
    		</div>
    	</div>
    	
    	<div class="portal" role="navigation" id="p-lang"  aria-labelledby="p-lang-label">
    		<h3  id="p-lang-label">
    			Languages
    		</h3>
    		<div class="body">
    			<ul><li class="interlanguage-link interwiki-ca"><a href="https://ca.wikipedia.org/wiki/Funcions_recursives_primitives" title="Funcions recursives primitives – Catalan" lang="ca" hreflang="ca" class="interlanguage-link-target">Català</a></li><li class="interlanguage-link interwiki-cs"><a href="https://cs.wikipedia.org/wiki/Primitivn%C4%9B_rekurzivn%C3%AD_funkce" title="Primitivně rekurzivní funkce – Czech" lang="cs" hreflang="cs" class="interlanguage-link-target">Čeština</a></li><li class="interlanguage-link interwiki-de"><a href="https://de.wikipedia.org/wiki/Primitiv-rekursive_Funktion" title="Primitiv-rekursive Funktion – German" lang="de" hreflang="de" class="interlanguage-link-target">Deutsch</a></li><li class="interlanguage-link interwiki-es"><a href="https://es.wikipedia.org/wiki/Recursi%C3%B3n_primitiva" title="Recursión primitiva – Spanish" lang="es" hreflang="es" class="interlanguage-link-target">Español</a></li><li class="interlanguage-link interwiki-fr"><a href="https://fr.wikipedia.org/wiki/Fonction_r%C3%A9cursive_primitive" title="Fonction récursive primitive – French" lang="fr" hreflang="fr" class="interlanguage-link-target">Français</a></li><li class="interlanguage-link interwiki-ko"><a href="https://ko.wikipedia.org/wiki/%EC%9B%90%EC%8B%9C_%EC%9E%AC%EA%B7%80_%ED%95%A8%EC%88%98" title="원시 재귀 함수 – Korean" lang="ko" hreflang="ko" class="interlanguage-link-target">한국어</a></li><li class="interlanguage-link interwiki-it"><a href="https://it.wikipedia.org/wiki/Funzione_ricorsiva_primitiva" title="Funzione ricorsiva primitiva – Italian" lang="it" hreflang="it" class="interlanguage-link-target">Italiano</a></li><li class="interlanguage-link interwiki-he"><a href="https://he.wikipedia.org/wiki/%D7%A4%D7%95%D7%A0%D7%A7%D7%A6%D7%99%D7%94_%D7%A4%D7%A8%D7%99%D7%9E%D7%99%D7%98%D7%99%D7%91%D7%99%D7%AA_%D7%A8%D7%A7%D7%95%D7%A8%D7%A1%D7%99%D7%91%D7%99%D7%AA" title="פונקציה פרימיטיבית רקורסיבית – Hebrew" lang="he" hreflang="he" class="interlanguage-link-target">עברית</a></li><li class="interlanguage-link interwiki-nl"><a href="https://nl.wikipedia.org/wiki/Primitief_recursieve_functie" title="Primitief recursieve functie – Dutch" lang="nl" hreflang="nl" class="interlanguage-link-target">Nederlands</a></li><li class="interlanguage-link interwiki-ja"><a href="https://ja.wikipedia.org/wiki/%E5%8E%9F%E5%A7%8B%E5%86%8D%E5%B8%B0%E9%96%A2%E6%95%B0" title="原始再帰関数 – Japanese" lang="ja" hreflang="ja" class="interlanguage-link-target">日本語</a></li><li class="interlanguage-link interwiki-pt"><a href="https://pt.wikipedia.org/wiki/Fun%C3%A7%C3%A3o_recursiva_primitiva" title="Função recursiva primitiva – Portuguese" lang="pt" hreflang="pt" class="interlanguage-link-target">Português</a></li><li class="interlanguage-link interwiki-ru"><a href="https://ru.wikipedia.org/wiki/%D0%A0%D0%B5%D0%BA%D1%83%D1%80%D1%81%D0%B8%D0%B2%D0%BD%D0%B0%D1%8F_%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F_(%D1%82%D0%B5%D0%BE%D1%80%D0%B8%D1%8F_%D0%B2%D1%8B%D1%87%D0%B8%D1%81%D0%BB%D0%B8%D0%BC%D0%BE%D1%81%D1%82%D0%B8)" title="Рекурсивная функция (теория вычислимости) – Russian" lang="ru" hreflang="ru" class="interlanguage-link-target">Русский</a></li><li class="interlanguage-link interwiki-sr"><a href="https://sr.wikipedia.org/wiki/%D0%9F%D1%80%D0%B8%D0%BC%D0%B8%D1%82%D0%B8%D0%B2%D0%BD%D0%B0_%D1%80%D0%B5%D0%BA%D1%83%D1%80%D0%B7%D0%B8%D0%B2%D0%BD%D0%B0_%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%98%D0%B0" title="Примитивна рекурзивна функција – Serbian" lang="sr" hreflang="sr" class="interlanguage-link-target">Српски / srpski</a></li><li class="interlanguage-link interwiki-uk"><a href="https://uk.wikipedia.org/wiki/%D0%A0%D0%B5%D0%BA%D1%83%D1%80%D1%81%D0%B8%D0%B2%D0%BD%D1%96_%D1%84%D1%83%D0%BD%D0%BA%D1%86%D1%96%D1%97" title="Рекурсивні функції – Ukrainian" lang="uk" hreflang="uk" class="interlanguage-link-target">Українська</a></li><li class="interlanguage-link interwiki-zh"><a href="https://zh.wikipedia.org/wiki/%E5%8E%9F%E5%A7%8B%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0" title="原始递归函数 – Chinese" lang="zh" hreflang="zh" class="interlanguage-link-target">中文</a></li></ul>
    			<div class="after-portlet after-portlet-lang"><span class="wb-langlinks-edit wb-langlinks-link"><a href="https://www.wikidata.org/wiki/Special:EntityPage/Q1570472#sitelinks-wikipedia" title="Edit interlanguage links" class="wbc-editpage">Edit links</a></span></div>
    		</div>
    	</div>
    	
    </div>
</div>

<div id="footer" role="contentinfo" >
	<ul id="footer-info" class="">
		<li id="footer-info-lastmod"> This page was last edited on 21 March 2020, at 10:37<span class="anonymous-show">&#160;(UTC)</span>.</li>
		<li id="footer-info-copyright">Text is available under the <a rel="license" href="//en.wikipedia.org/wiki/Wikipedia:Text_of_Creative_Commons_Attribution-ShareAlike_3.0_Unported_License">Creative Commons Attribution-ShareAlike License</a><a rel="license" href="//creativecommons.org/licenses/by-sa/3.0/" style="display:none;"></a>;
additional terms may apply.  By using this site, you agree to the <a href="//foundation.wikimedia.org/wiki/Terms_of_Use">Terms of Use</a> and <a href="//foundation.wikimedia.org/wiki/Privacy_policy">Privacy Policy</a>. Wikipedia® is a registered trademark of the <a href="//www.wikimediafoundation.org/">Wikimedia Foundation, Inc.</a>, a non-profit organization.</li>
	</ul>
	<ul id="footer-places" class="">
		<li id="footer-places-privacy"><a href="https://foundation.wikimedia.org/wiki/Privacy_policy" class="extiw" title="wmf:Privacy policy">Privacy policy</a></li>
		<li id="footer-places-about"><a href="/wiki/Wikipedia:About" title="Wikipedia:About">About Wikipedia</a></li>
		<li id="footer-places-disclaimer"><a href="/wiki/Wikipedia:General_disclaimer" title="Wikipedia:General disclaimer">Disclaimers</a></li>
		<li id="footer-places-contact"><a href="//en.wikipedia.org/wiki/Wikipedia:Contact_us">Contact Wikipedia</a></li>
		<li id="footer-places-developers"><a href="https://www.mediawiki.org/wiki/Special:MyLanguage/How_to_contribute">Developers</a></li>
		<li id="footer-places-statslink"><a href="https://stats.wikimedia.org/#/en.wikipedia.org">Statistics</a></li>
		<li id="footer-places-cookiestatement"><a href="https://foundation.wikimedia.org/wiki/Cookie_statement">Cookie statement</a></li>
		<li id="footer-places-mobileview"><a href="//en.m.wikipedia.org/w/index.php?title=Primitive_recursive_function&amp;mobileaction=toggle_view_mobile" class="noprint stopMobileRedirectToggle">Mobile view</a></li>
	</ul>
	<ul id="footer-icons" class="noprint">
		<li id="footer-copyrightico"><a href="https://wikimediafoundation.org/"><img src="/static/images/wikimedia-button.png" srcset="/static/images/wikimedia-button-1.5x.png 1.5x, /static/images/wikimedia-button-2x.png 2x" width="88" height="31" alt="Wikimedia Foundation"/></a></li>
		<li id="footer-poweredbyico"><a href="https://www.mediawiki.org/"><img src="/static/images/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" srcset="/static/images/poweredby_mediawiki_132x47.png 1.5x, /static/images/poweredby_mediawiki_176x62.png 2x" width="88" height="31"/></a></li>
	</ul>
	<div style="clear: both;"></div>
</div>

<script>(RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgPageParseReport":{"limitreport":{"cputime":"0.264","walltime":"0.382","ppvisitednodes":{"value":1257,"limit":1000000},"postexpandincludesize":{"value":37064,"limit":2097152},"templateargumentsize":{"value":4631,"limit":2097152},"expansiondepth":{"value":13,"limit":40},"expensivefunctioncount":{"value":0,"limit":500},"unstrip-depth":{"value":1,"limit":20},"unstrip-size":{"value":21564,"limit":5000000},"entityaccesscount":{"value":0,"limit":400},"timingprofile":["100.00%  266.106      1 -total"," 49.77%  132.429      1 Template:Reflist"," 33.68%   89.628      2 Template:Citation"," 21.61%   57.510      2 Template:Isbn","  9.93%   26.412      3 Template:Ordered_list","  8.19%   21.793      3 Template:Cite_book","  7.38%   19.643      2 Template:Catalog_lookup_link","  7.21%   19.175      1 Template:Mathematical_logic","  5.80%   15.423      1 Template:Navbox","  4.98%   13.239      1 Template:Block_indent"]},"scribunto":{"limitreport-timeusage":{"value":"0.104","limit":"10.000"},"limitreport-memusage":{"value":2962191,"limit":52428800}},"cachereport":{"origin":"mw1323","timestamp":"20200401065617","ttl":2592000,"transientcontent":false}}});});</script>
<script type="application/ld+json">{"@context":"https:\/\/schema.org","@type":"Article","name":"Primitive recursive function","url":"https:\/\/en.wikipedia.org\/wiki\/Primitive_recursive_function","sameAs":"http:\/\/www.wikidata.org\/entity\/Q1570472","mainEntity":"http:\/\/www.wikidata.org\/entity\/Q1570472","author":{"@type":"Organization","name":"Contributors to Wikimedia projects"},"publisher":{"@type":"Organization","name":"Wikimedia Foundation, Inc.","logo":{"@type":"ImageObject","url":"https:\/\/www.wikimedia.org\/static\/images\/wmf-hor-googpub.png"}},"datePublished":"2001-12-07T15:36:31Z","dateModified":"2020-03-21T10:37:45Z"}</script>
<script>(RLQ=window.RLQ||[]).push(function(){mw.config.set({"wgBackendResponseTime":111,"wgHostname":"mw1369"});});</script></body></html>
